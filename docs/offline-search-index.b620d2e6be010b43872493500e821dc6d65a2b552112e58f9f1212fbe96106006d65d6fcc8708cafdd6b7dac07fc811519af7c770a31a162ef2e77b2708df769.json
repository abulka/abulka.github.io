[{"body":"Introduction Andy‚Äôs Published Design Patterns These four papers are substantial works which have been presented at KoalaPlop (Asian Pacific Conference on Pattern Languages of Programs) in both 2000 and 2001. My shepherds (paper peer reviewers) were:\n Jim Coplien (MGM pattern) Ali Arsanjani (TI pattern) James Noble (RM pattern). (Design Pattern Automation) was not peer reviewed before being presented and published.  These final versions also incorporate comments and reviews from the attendees of KoalaPlop 2000 and 2001.\n","excerpt":"Introduction Andy‚Äôs Published Design Patterns These four papers are ‚Ä¶","ref":"/projects/patterns/","title":"Design Patterns"},{"body":"Apps and Websites released this year - 2019 GitUML UML visualisation for Git repositories (website app).\nUnderstand code quickly:¬†Automatically generate UML class diagrams from source code residing in git repositories.¬†Diagrams automatically update when you push code using git.\nVisit GitUML now, create a free account and begin creating UML diagrams and documentation.\nPynsource UML tool for Python (Desktop App for Mac, Window, Linux) - brand new version.¬†Zoom in and out. PlantUML view. Auto Layout. Import Python 3 code.\nVersion 1.71¬†- new for 2019\nVisit the brand new dedicated website pynsource.com.\nBuy the Pro Edition for $20 to unlock the zoom feature.¬†Community Edition is fully functional and open source - check out the github repository.¬†Donate to support this project (donate link coming soon).\nMy Apps and Websites - 2018 Print42 Print42 is a log tailing GUI program which optionally echoes log lines to thermal printer tape. Its like a modern thermal printer version of a ticker tape for tailing log files. It features display font size options, search and filtering. You can also annotate the output with text fragments that you type in - or screenshots that you paste in.\nThe video is 13 minutes long and covers the basic use cases, history of the project etc.\nAs well as physically printing from Free42, the Print42 software can also be used to print HP Prime screenshots (from either the emulator or real HP Prime hardware via the HP connectivity kit).\nOutside the world of calculators, Print42 can be used to ‚Äòtail‚Äô log files (programmers take note) and to print graphic snippets from the web. Useful if you want to rapidly print information to stuff into your pocket or to study and annotate printouts of complex information, at your desk.\nIf you are looking for a useful, fun new gadget, you might want to consider buying an Epson thermal printer and trying Print42. However you can also use Print42 with your regular desktop printer, for free.\nThe website for downloads and further information is¬†www.print42.atug.com\nPython to RPN I am pleased to announce the Python to HP42S RPN converter website is online.\nwww.pyrpn.atug.com¬†You write code in a high level structured language (which happens to be Python 3 syntax), hit a button and RPN is generated.¬†You then paste the RPN into Free42 or transfer it to your DM42 (by¬†creating a raw) - and it runs.\n Examples:¬†http://www.pyrpn.atug.com/examples User Guide:¬†http://www.pyrpn.atug.com/help Canvas for 42S Simulator:¬†http://www.pyrpn.atug.com/canvas List of HP42S Commands Supported Reference:¬†http://www.pyrpn.atug.com/cmds  The converter supports core Python syntax (which is very powerful), but does not implement the built in Python libraries that you would get in desktop Python. You have to rely on the ability to call HP42S commands from Python to do your work - which of course you can do. Specifically, it has the following capabilities:\n Variables Functions, Multiple functions, nested functions Parameter passing, receiving return values, multiple return values if elif else Comparison operators == != \u003e \u003c \u003e= \u003c= Booleans True, False and operators not or and for loops, range(), for..in iteration through lists and dictionary keys while loops, while‚Ä¶else continue and break operations in for loops and while loops Lists and Dictionaries (basic operations only). Matrices, Pythonic matrix element access syntax [row,col] NumPy compatible slicing syntax for sub-matrices Complex numbers using either 42S or Python native syntax Expressions involving nested brackets assert Testing and clearing of flags Access most HP42S commands as function calls e.g. FIX(2) Some enhanced functions to make life easier e.g. varmenu() automates and simplifies the generation of MVAR based code.  My Other Apps and Consulting Services If you would like me to run a design patterns course or consult on your next software design, please check out my¬†product¬†page.¬†There is also an open source¬†Python UML tool¬†you might be interested in, plus references to products I have developed over the years esp. the worldclass argumentation visualisation software Rationale and bCisive.\nMy Medium Articles - 2018 - 2020 I‚Äôve been publishing a lot on Medium recently. Why? Because the articles seems to get more widely read, and the Medium editor is so simple and produces beautifully formatted articles.\nBuilding a deployable Python-Electron App\nBuilding a normal, deployable application for Mac or Windows, using Python 3 is hard. There is nothing like Visual Studio or Delphi (remember that?) for Python where you can drag and drop to design a GUI, press a button and get an .exe or .app to give people. Sad. The closest you can get is to follow a long recipe of steps - which I outline here.\nAsync/await for wxPython\nPython 3 GUI apps with asynchronous functionality\nGetting Python and wxPython apps into the Ubuntu app store\nHave you ever dreamt of getting your own apps in the Ubuntu app store? Here‚Äôs how.\nDjango View logging is back-the-front\nHow the order of view request log messages in Django apps might be confusing, and how to fix it.\nTodoMVC implemented using traditional OO, Controllers and Events.\nTodoMVC implemented in a classic Object Oriented way -¬†which includes running code you can run in your browser.\nTodoMVC implemented using a game architecture ‚Äî ECS.\nBuilding traditional GUIs with the Entity Component System\nComing soon\nLiterate Code Maps\nComing soon: A Medium article - for now this is a GitHub page. I‚Äôve invented a diagramming methodology called Literate Code Maps which improve upon some aspects of UML - actually they are quite different and arguably more useful than UML for understanding complex source code projects. I‚Äôve been using this notation for many years, and it might help you in your projects.\nGitHub Projects A pair of extensions for Visual Studio Code Snippets Explorer Visual Studio Code extension which displays all available language snippets in a TreeView\nhttps://github.com/abulka/vscode-snippets-explorer\nSnippet Creator This extension helps to automate snippet creation. Select the code you want to create snippet from and use command Create Snippet from the command palette or your custom keybind.\nhttps://github.com/abulka/vscode-snippet-creator\nBrew Moments I‚Äôve recently learned mobile app development using Flutter.¬†Here is my first app.\nhttps://abulka.github.io/brew-moments/\n\nSidebar My Developer Story This stackoverflow timeline is like a resume - except its more fun and useful to look at.\n Story view Traditional view¬†  Building a deployable Python-Electron App Here is my latest article, published on Medium, about how to use Electron as a GUI front end to Python 3. It gets over 1,000 reads a week for some reason, more than any of my other articles.\nTodoMVC implementation articles Here are my two recent articles implementing the classic Javascript TodoMVC app in various ways. These two articles shows you how to design apps. Its an alternative to using a modern javascript framework like Vue, Angular or React.\n Classic¬†- OO, Controllers and Events ECS - using a game architecture  xx this is a test\nPynsource UML tool for Python source code - visit www.pynsource.com\nVersion¬†1.76¬†- released Apr 22, 2020\n- Zoom, zoom to fit\n- Python 3 compatibility\n- New accurate AST based python parser\n-¬†Layout algorithm\n-¬†Ascii UML view built into the GUI, including an innovative Ascii UML layout\n- PlantUML view for beautiful renderings of UML\n-¬†Colour sibling nodes\n-¬†Open Source\nPrint42 Print42 is a log tailing GUI program which optionally echoes log lines to thermal printer tape. Its like a modern thermal printer version of a ticker tape for tailing log files. It features display font size options, search and filtering. You can also annotate the output with text fragments that you type in - or screenshots that you paste in.\nPython to RPN converter Check out Python to RPN if you have an old vintage HP Calculator that you want to program in Python!¬†Impossible?¬†See also my blog post¬†How I used the Python AST capabilities to build a¬†Python to Rpn converter.\nHexMVC - Design Pattern HexMVC - A new, lightweight, architectural pattern for building applications based on the Hexagonal layered architecture pattern + MVC ‚Äì presented by Andy Bulka.¬†To be published 2019.\nDesign Patterns Training Elevate the effectiveness of your entire programming team - Andy can deliver his existing or a customised Design Patterns Course to your entire programming team - at your company‚Äôs premises.¬†Check out the details.\n Summary after this point there will be a summary list of pages within the Projects\n","excerpt":"Apps and Websites released this year - 2019 GitUML UML visualisation ‚Ä¶","ref":"/projects/misc/","title":"Misc"},{"body":"Abstract Basically describes a lightweight, in-memory Object Database.\nClasses that use a Relationship Manager to implement their relationship properties and methods have a consistent metaphor and trivial implementation code (one line calls). In contrast - traditional ‚Äúpointer‚Äù and ‚Äúarraylist‚Äù techniques of implementing relationships are fully flexible but often require a reasonable amount of non-trivial code which can be tricky to get working correctly and are almost always a pain to maintain due to the detailed coding and coupling between classes involved, especially when back-pointers are involved.\nUsing a Relationship Manager object to manage the relationships can mitigate these problems and make managing relationships straightforward. It also opens up the possibility of powerful querying of relationships, a very simple version of something like LINQ.\nIn a sense, an Object Database is an elaborate implementation of the Relationship Manager pattern. However the intent of the Relationship Manager pattern is lighter weight, to replace the wirings between objects rather than acting as a huge central database on disk - though persistence is built into Relationship Manager too.\nThe Official Pattern Note this pattern was written and presented in 2001 - quite a while ago! In 2020 the API of the Python Relationship Manager implementation was revised and improved - see full API documentation.\n Download as pdf.\nQuick Example The examples on this page use the modern v2. Python implementation.\nRelationship Manager has also been implemented in Python, C# (.net4 and .net core) and Java - see the Relationship Manager GitHub project for all implementation source code.\nInstallation pip install relationship-manager Usage from relmgr import RelationshipManager rm = RelationshipManager() rm.enforce(\"xtoy\", \"onetoone\", \"directional\") x = object() y = object() rm.add_rel(x, y, \"xtoy\") assert rm.find_target(x, \"xtoy\") == y Benefits  Modelling relationships is easy and consistent Back pointer are free Using a query language (think LINQ) is possible over your objects Optional constraints ensure wrong wirings are not made  Traditional object oriented programmers wire up their objects manually using pointers and arrays, whereas database programmers save their objects in a database and let the database model the relationships.\nProgrammers often use ORM mappers to get the best of both worlds - objects which also have a representation in a database. Relationship Manager is another solution to being able to more easily model and query your objects - without needing a database.\nQueries You can make queries on the Relationship Manager instance:\n# query API def find_targets(self, source, rel_id) -\u003e List: def find_target(self, source, rel_id) -\u003e object: def find_sources(self, target, rel_id) -\u003e List: # Back pointer query def find_source(self, target, rel_id) -\u003e object: # Back pointer query def find_rels(self, source, target) -\u003e List: def is_rel(self, source, target, rel_id=1) -\u003e bool: Constrained Relationships You can enforce relationships.¬†For example enforce() works like this:\nrm.enforce(\"xtoy\", \"onetoone\", \"directional\") The relationship is registered as being one to one and directional, so that e.g. when you add a second relationship between the same two objects the first relationship is automatically removed - ensuring the relationship is always one to one. Alternatively, the implementation could raise an exception (go into the source and change it if this is what you need).\nModelling relationships What methods do I put where when modelling relationships?\nWhat are all the possibilities of relationships between two classes?\nWhen looking at all the possibilities of relationships between two classes, you get\n one to one one to many many to one many to many  Then you have the variations generated by whether the relationships are either\n directional bi-directional  Finally, you have variations of whether you put pointer methods (e.g. set, get, add) on one class or the other, or both.\nFor example, assuming you have a two classes one on the lhs and one on the rhs - you could omit methods on e.g. the rhs. class, or you could go to the other extreme and provide a full range of methods on the rhs. class.¬†I recommend that you use the table of relationship scenarios table to figuring out what methods to put where for each type of classic relationship you want to model.¬†For example, to implement a one to many relationship between two classes X and Y, you would use template 4 or 5 (use the latter if you want bidirectionality)\nNote that some combinatorial possibilities do not make sense and are left out of the table below.¬† S means singular API - this makes sense for one to one relationships, or the many side (ironically) of one to many relationships.¬†It consists of methods like get, set, clear. P means plural API- this makes sense where you are dealing with collections, a many concept.¬†It consists of methods like add, remove, getall. -¬†means no methods relating to the relationship have been implemented on that class.  Blank cells mean ‚Äúnot applicable‚Äù.\n   Scenario # see below directional bi-directional comments      one to one\n1 --\u003e 1 one to one\n1 \u003c--\u003e¬†1    #1. S¬†- ¬†    #2. -¬†S ¬†    #3. ¬† S¬†S using ‚Äòbidirectional‚Äô relationship, which creates two relationship entries   #3A. ¬† S¬†S alternative implementation using a single ‚Äòdirection‚Äô relationship - the bidirectionality is figured out using the magic of rm.find_source()    one to many\n1 --\u003e * one to many\n1¬†\u003c--\u003e¬†*    #4. P¬†- ¬†    #5. ¬† P¬†S using ‚Äòbidirectional‚Äô relationship, which creates two relationship entries   #5A. ¬† P¬†S alternative implementation using a single ‚Äòdirection‚Äô relationship - the bidirectionality is figured out using the magic of rm.find_source()    many to one\n*¬†--\u003e¬†1 many to one\n*¬†\u003c--\u003e¬†1    #6. -¬†P ¬†    #7. ¬† S¬†P     many to many\n* --\u003e¬†* many to many\n*¬†\u003c--\u003e¬†*    #8. P¬†-  ¬†   #9. -¬†P ¬†    #10. ¬† P¬†P     An attempt at mapping the theoretical relationship possibilities\nThe above table shows all the possible relationship scenarios between two classes.¬†It indicates various possibilities as to the methods you can add to either class.¬†For example a one to many relationship where the ‚Äúmany‚Äù side has no need of any methods to see who is pointing at it, would use template 4.\nTable of Relationship Scenarios How to implement relationships using sets of Relationship Manager methods\nHere is a list of classic ‚Äúrelationship scenarios‚Äù (e.g. one to one, one to many etc.) and how to implement them using the Relationship Manager API.\nThe right hand side of the below table shows python code using calls to RM (relationship manager) using the shorthand notation for the function names.¬†For long hand names just substitute in the appropriate name e.g. instead of RM.R() you would call rm.AddRelationship().\nNote: The method names below are just suggestions. Normally you would use better method names that pertain to your application domain.\n Instead of .addY(y) you might have addOrder(order). Instead of .getX() you might have getCustomer(). Instead of getAllY() you might have .getOrders() etc.  Here is the table:\n Look up the scenario you need to implement on the left, then use the template implementation on the right in your code.    Relationship Scenario Example Python Implementation   Implementing one to one relationships between class X and Y        #1.  1¬†‚Üí 1, directional, all methods on X\n Singular API¬†No API ______________ ______________ | X | | Y | |______________| |______________| | | | | |void setY(y) |1 1| | |Y getY() |‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚Üí| | |void clearY()| | | |______________| |______________|  Note: The clearY() implementation needs to get a reference to y in order to call remove_rel(x, y, ...) which is done by calling getY() on itself.\n   class X: def __init__(self): rm.enforce(\"xtoy\", \"onetoone\", \"directional\") def setY(self, y): rm.add_rel(self, y, \"xtoy\") def getY(self): rm.find_target(source=self, rel_id=\"xtoy\") def clearY(self): rm.remove_rel(self, self.getY(), \"xtoy\")   class Y: pass     #2.  1¬†‚Üí 1, directional, all methods on Y\n No API¬†Singular API ______________ ______________ | X | | Y | |______________| |______________| | | | | | |1 1| setX(x) | | |‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚Üí | getX() | | | | clearX() | |______________| |______________|     class X: pass   class Y: def __init__(self): rm.enforce(\"xtoy\", \"onetoone\", \"directional\") def setX(self, x): rm.add_rel(x, self, \"xtoy\") def getX(self): rm.find_source(target=self, rel_id=\"xtoy\") def clearX(self): rm.remove_rel(self.getX(), self, \"xtoy\")     #3.  1¬†‚Üê‚Üí¬†1, bi-directional, methods on both X and Y\n Singular API¬†Singular API ______________ ______________ | X | | Y | |______________| |______________| | | | | |void setY(y) |1 1| setX(x) | |Y getY() | ‚Üê‚éØ‚éØ‚éØ‚éØ‚Üí | getX() | |void clearY()| | clearX() | |______________| |______________|     class X: def __init__(self): rm.enforce(\"xy\", \"onetoone\", \"bidirectional\") def setY(self, y): rm.add_rel(self, y, \"xy\") def getY(self): rm.find_target(self, \"xy\") def clearY(self): rm.remove_rel(self, self.getY(), \"xy\")   class Y: def __init__(self): rm.enforce(\"xy\", \"onetoone\", \"bidirectional\") def setX(self, x): rm.add_rel(self, x, \"xy\") def getX(self): rm.find_target(self, \"xy\") def clearX(self): rm.remove_rel(self, self.getX(), \"xy\")     #3A.  1¬†‚Üê‚Üí¬†1, bi-directional, methods on both X and Y\nAlternative implementation of scenario 3, using \"directional\" and a backpointer method\n diagram as above     class X: def __init__(self): rm.enforce(\"xy\", \"onetoone\", \"directional\") # different to 3. # uses 'directional' not 'bidirectional' def setY(self, y): rm.add_rel(self, y, \"xy\") # same as 3. def getY(self): rm.find_target(self, \"xy\") # same as 3. def clearY(self): rm.remove_rel(self, self.getY(), \"xy\") # same as 3.   class Y: def __init__(self): rm.enforce(\"xy\", \"onetoone\", \"directional\") # different to 3. # uses 'directional' not 'bidirectional' # redundant call since already called in X's constructor def setX(self, x): # different to 3. rm.add_rel(self, x, \"xy\") # source and target params swapped def getX(self): # different to 3. rm.find_source(self, \"xy\") # uses 'find_source' not 'find_target' def clearX(self): # different to 3. rm.remove_rel(self, self.getX(), \"xy\") # source and target params swapped      Notes on Scenario 3 and 3A:\n  When you create a bi-directional enforcement rule (Scenario 3) with a call to rm.enforce(\"xy\", \"onetoone\", \"bidirectional\") you are actually causing rm to create two relationship entries in the rm. This means you can reliably use a rm.find_target(source=self) call from either side, knowing there is a relationship in both directions.\n  When you create a directional enforcement rule (Scenario 3A) with a call to rm.enforce(\"xy\", \"onetoone\", \"directional\") or leave out this call altogether, you are causing rm to create only the relationships that you ask for. Thus classes on the 'target' side of a relationship cannot call rm.find_target(source=self) to find out who is pointing to them. They can however, thanks to the magic of rm, call rm.find_source() to derive this information.   This means bidirectional relationships never actually need to be used or declared, üò≤, since an implicit back-pointer (i.e. a back reference) is always deducible using rm.find_source(), when using a Relationship Manager! In fact a bidirectional relationship creates extra entries in the rm datastructure, and slightly more overhead in performance (maintaining both relationships e.g. in the case of creation and removal).\nHowever you may still want to declare a bidirectional relationship for its semantic value in your particular business logic domain, or for domain modelling accuracy - or even just for your own implementation preferences.      Implementing one to many relationships between class X and Y      #4.  1¬†‚Üí¬†*, directional, all methods on X\n Plural¬†API¬†No API _____________ ______________ | X | | Y | |_____________| |______________| | | | | |addY(y) |1 *| | |getAllY() | ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚Üí | | |removeY(y) | | | |_____________| |______________|     class X: def __init__(self): rm.enforce def addY(self, y): rm.add_rel(self, y, \"xtoy\") def getAllY(self): rm.find_targets(self, \"xtoy\") def removeY(self, y): rm.remove_rel(self, y, \"xtoy\")   class Y: # no methods on rhs pass     #5.  1¬†‚Üê‚Üí¬†*, bi-directional, methods on both X and Y\n Plural¬†API¬†Singular API _____________ ______________ | X | | Y | |_____________| |______________| | | | | |addY(y) |1 *| setX(x) | |getAllY() | ‚Üê‚éØ‚éØ‚éØ‚éØ‚Üí | getX() | |removeY(y) | | clearX() | |_____________| |______________|   X has the required plural API Y has the reciprocal singular API   Since there are two API's, one on each class, this makes it a bidirectional relationship.  However - there still remains a sense of directionality because the one to many is directional i.e. the the lhs. 'one' side is the X and the rhs. 'many' side is the Y, not the other way around.    class X: def __init__(self): rm.enforce(\"xtoy\", \"onetomany\", \"bidirectional\") def addY(self, y): rm.add_rel(self, y, \"xtoy\") def getAllY(self): rm.find_targets(self, \"xtoy\") def removeY(self, y): rm.remove_rel(self, y, \"xtoy\")   class Y: # though bi, there is still a direction! def setX(self, x): rm.add_rel(x, self, \"xtoy\") def getX(self): rm.find_target(self, \"xtoy\") def clearX(self): rm.remove_rel(self, self.getX(), \"xtoy\")     #5A.  1¬†‚Üê‚Üí¬†*, bi-directional, methods on both X and Y\nAlternative implementation of scenario 5, using \"directional\" and a backpointer method\n diagram as above     class X: def __init__(self): rm.enforce(\"xtoy\", \"onetomany\", \"directional\") # different to 5 # uses 'directional' not 'bidirectional' def addY(self, y): rm.add_rel(self, y, \"xtoy\") # same as 5. def getAllY(self): rm.find_targets(self, \"xtoy\") # same as 5. def removeY(self, y): rm.remove_rel(self, y, \"xtoy\") # same as 5.   class Y: def setX(self, x): rm.add_rel(x, self, \"xtoy\") # same as 5. def getX(self): rm.find_source(self, \"xtoy\") # different to 5 # uses 'find_source' not 'find_target' def clearX(self): rm.remove_rel(self.getX(), self, \"xtoy\") # different to 5 # source and target params swapped     Implementing many to one relationships between class X and Y      #6.  * ‚Üí¬†1, directional, all methods on Y\n No API¬†Plural¬†API ______________ ______________ | X | | Y | |______________| |______________| | | | | | |* 1|addX(x) | | | ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚Üí |getAllX() | | | |removeX(x) | |______________| |______________|    DRAFT API (not tested)\n class X: pass   class Y: def addX(x) - None: rm.add_rel(x, this, \"xtoy\") def getAllX() - List: return rm.find_sources(this, \"xtoy\") def removeX(x) - None: rm.remove_rel(x, this, \"xtoy\")  \n   #7.  *¬†‚Üê‚Üí¬†1, bi-directional, methods on both X and Y\n Singular API¬†Plural¬†API ______________ ______________ | X | | Y | |______________| |______________| | | | | |void setY(y) |* 1|addX(x) | |Y getY() | ‚Üê‚éØ‚éØ‚éØ‚éØ‚Üí |getAllX() | |void clearY()| |removeX(x) | |______________| |______________|    DRAFT API (not tested)\n class X: def setY(y) - None: rm.add_rel(this, y, \"xtoy\") def getY() - Y: rm.find_target(this, \"xtoy\") def clearY() - None: rm.remove_rel(this, getY(), \"xtoy\")   class Y: def addX(x) - None: rm.add_rel(x, this, \"xtoy\") def getAllX() - List: rm.find_sources(this, \"xtoy\") def removeX(x) - None: rm.remove_rel(x, this, \"xtoy\")  \n   Implementing many to many relationships between class X and Y      #8.  *¬†‚Üí¬†*, directional, all methods on X\n Plural¬†API¬†No API _____________ ______________ | X | | Y | |_____________| |______________| | | | | |addY(y) |* *| | |getAllY() | ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚Üí | | |removeY(y) | | | |_____________| |______________|    DRAFT API (TODO, not tested)\n   #9.  *¬†‚Üí¬†*, directional, all methods on Y\n No API¬†Plural¬†API ______________ ______________ | X | | Y | |______________| |______________| | | | | | |* *|addX(x) | | | ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚Üí |getAllX() | | | |removeX(x) | |______________| |______________|    DRAFT API (TODO, not tested)\n   #10.  *¬†‚Üê‚Üí¬†*, bi-directional, methods on both X and Y\n Plural¬†API¬†Plural¬†API ______________ ______________ | X | | Y | |______________| |______________| | | | | | addY(y) |* *| addX(x) | | getAllY() | ‚Üê‚éØ‚éØ‚éØ‚éØ‚Üí | getAllX() | | removeY(y) | | removeX(x) | |______________| |______________|    DRAFT API (TODO, not tested)\n    These scenarios are all unit tested in tests/python/test_enforcing.py in the GitHub project.\n Back pointers One of the benefits of the relationship manager pattern is that you don‚Äôt have to explicitly wire up and maintain back-pointers.¬†Once you add a pointer relationship, you get the back pointer relationship available, for free.¬†And once you delete the pointer relationship, the back-pointer relationship goes away automatically too.\nThe following code is a good example of how the use of RM saves you from having to explicitly maintain backpointers. P.S. To run the code you also need the support files found here.¬†View the code below (requires the flash plugin) - showing an implementation of a Composite Pattern, with back pointer - or simply read the pdf directly.\n Backpointers are pointers on the ‚Äútarget end‚Äù of a relationship, so that the target object knows who is pointing at it.¬†For example when a Customer places an Order, it might be convenient for any particular order instance to know which customer ordered it.¬†I think you can choose to conceive of the backpointer in a few different ways:\n as an extra, separate relationship or as part of the one bidirectional relationship or merely a convenience method in the implementation in the r.h.s. class  The easiest way of implementing this backpointer without using relationship manager is to follow the Martin Fowler refactoring technique - see Martin Fowler ‚ÄòRefactorings‚Äô p. 197 ‚ÄúChange Unidirectional Association to Bidirectional‚Äù - this will ensure you get the wiring correct.¬†In this refactoring, you decide which class is the master and which is the slave etc.¬†See the before and after python pdf below for an example of the correct wiring.\nThe way of implementing a backpointer using relationship manager is simply to call the rm.find_source(target=self) method.¬†Since a rm holds all relationships, it can answer lots of questions for free - just like SQL queries to a database.\n Bi-directional relationships A bi-directional relationship between X and Y means both sides have pointers to each other.\nor just\nWithin this seemingly obvious idea are a myriad of nuances:\nWe must distinguish between a relationship that in its domain meaning, goes both ways, and a relationship which goes one way only.¬†And furthermore, implementationally, you can have RM methods on one class only, on the other class only, or on both classes.¬†The meaning of the relationship and the implementation (methods to create and look up those relationships) are two different things!\n As the diagram above shows, one bi-bidirectional relationship is arguably shorthand for two directional relationships.  In fact in the Python rm implementation, when you create a bi-directional enforcement rule (e.g. Scenario 3) with a call to rm.enforce(‚Äúxy‚Äù, ‚Äúonetoone‚Äù, ‚Äúbidirectional‚Äù) you are actually causing rm to create two relationship entries in the rm. This means you can reliably use a rm.find_target(source=self) call from either side, knowing there is a relationship in both directions.\n The methods you implement on your classes to create and look up relationships can influence your perception of what is pointing to what.  When you put an API (relationship manager methods) on both classes this might seem to imply that you are implementing bi-directionality - however this does not mean that the ‚Äúsemantic relationship‚Äù points in both directions.¬†The meaning of the relationship is often in one direction only, and the existence of methods on both classes merely gives you a convenient way of querying the directional relationship that exists.\nA rm, like a database, allows you to ‚Äòcheat‚Äô and find out who is pointing to a class even though that class has no actual pointers implementing ‚Äòam pointed to by‚Äô. This is accomplished by using rm.find_source(target=self). But just because a rm let‚Äôs you find out this knowledge doesn‚Äôt mean there is a official modelling of this back-relationship in your domain.\n Back-pointer relationships are not the same thing as official, semantic relationships.  However you may still want to declare a bidirectional relationship for its semantic value in your particular business logic domain, or for domain modelling accuracy - or even just for your own implementation preferences.\n A bi-directional relationship (pair) can be implemented more efficiently by a single directional relationship together with the magic rm back-pointer lookup call rm.find_source(target=self).  When you create a directional enforcement rule (e.g. Scenario 3A) with a call to rm.enforce(‚Äúxy‚Äù, ‚Äúonetoone‚Äù, ‚Äúdirectional‚Äù) or leave out this call altogether, you are causing rm to create only the relationships that you ask for. Thus classes on the ‚Äòtarget‚Äô side of a relationship cannot call rm.find_target(source=self) to find out who is pointing to them. They can however, thanks to the back-pointer lookup magic of rm, call rm.find_source(target=self) to derive this information.\nThis means bidirectional relationships never actually need to be used or declared, üò≤, since an implicit back-pointer (i.e. a back reference) is always deducible using rm.find_source(), when using a Relationship Manager! In fact a bidirectional relationship creates extra entries in the rm datastructure, and slightly more overhead in performance (maintaining both relationships e.g. in the case of creation and removal).\n Name your relationships with direction in mind If you choose to implement relationship related methods on both classes use the same relationship id on both sides.  The same relationship id should be used in both classes e.g. \"xtoy\" (notice the sense of directionality is built into the name of the relationship!). Even though there is an API on both classes allowing each class to find the other class, does not turn the relationship semantics to be bi-directional from the point of view of domain modelling, but only in a convenient implementation sense.¬†Some may frown on this ability of an implementation to cheat and betray the domain model. Perhaps a flag could be set in the rm to disallow use of the back-pointer lookup magic rm.find_source(target=self) of rm,.\nIn the following implementation of a one to many relationship between class X and class Y, notice the same relationship id¬†\"xtoy\" must be used in both classes.\nclass X: def __init__(self): rm.enforce(\"xtoy\", \"onetoone\", \"directional\") def setY(self, y): rm.add_rel(self, y, \"xtoy\") def getY(self): return rm.find_target(self, \"xtoy\") def clearY(self): rm.remove_rel(self, self.getY(), \"xtoy\") class Y: def __init__(self): rm.enforce(\"xtoy\", \"onetoone\", \"directional\") # probably redundant def setX(self, x): rm.add_rel(x, self, \"xtoy\") def getX(self): return rm.find_source(self, \"xtoy\") def clearX(self): rm.remove_rel(self.getX(), self, \"xtoy\") Note that both classes calling rm.enforce is possibly redundant, since its telling the rm the same information - depending on the order of initialisation of your classes.\nExamples Python Example - Observer pattern Here is an example of hiding the use of Relationship Manager, found in the examples folder as relmgr/examples/observer.py - the classic Subject/Observer pattern:\nfrom relmgr import RelationshipManager rm = RelationshipManager() class Observer: @property def subject(self): return rm.find_target(self) @subject.setter def subject(self, _subject): rm.add_rel(self, _subject) def notify(self, subject, notification_type): pass # implementations override this and do something class Subject: def notify_all(self, notification_type: str): observers = rm.find_sources(self) # all things pointing at me for o in observers: o.Notify(self, notification_type) def add_observer(self, observer): rm.add_rel(observer, self) def remove_observer(self, observer): rm.remove_rel(source=observer, target=self) When using the Subject and Observer, you use their methods without realising their functionality has been implemented using rm. See tests/python/examples/test_observer.py in the GitHub project for the unit tests for this code.\nC# Example - modelling Person ‚Äì\u003e* Order Say you want to model a Person class which has one or more Orders.¬†The Order class needs to have a backpointer - back to the Person owning that order.\nInstead of hand coding and reinventing techniques for doing all the AddOrder() methods and GetOrders() methods etc. using ArrayLists and whatever, we can do it using the relationship manager object instead, which turns out to be simpler and faster and less error prone.¬†The RM (relationship manager) is implemented in this particular example as a static member of the base BO (business object) class.¬†Thus in this situation all business objects will be using the same relationship manager.\n Note that the use of Relationship Manager is hidden, and is a mere implementation detail.\n Here is the c# code to implement the above UML. This code uses the v1 API documented in the Relationship Manager GitHub project:\nusing System; using System.Collections; using System.Collections.Generic; using RelationshipManager.Interfaces; using RelationshipManager.Turbo; namespace Example_Person_Order_Console_App { class Program { static void Main(string[] args) { var jane = new Person(\"Jane\"); var order1 = new Order(\"Boots\"); var order2 = new Order(\"Clothes\"); jane.AddOrder(order1); jane.AddOrder(order2); // test forward pointer wiring  Console.WriteLine(jane + \" has \" + jane.GetOrders().Count + \" orders\"); // test the backpointer wiring  foreach (var order in jane.GetOrders()) { Console.WriteLine(\"The person who ordered \" + order + \" is \" + order.GetPerson()); } Console.WriteLine(\"Done!\"); } ///  /// BO is the base Business Object class which holds a single static reference  /// to a relationship manager. This one relationship manager is  /// used for managing all the relationships between Business Objects  /// like Person and Order.  ///  public class BO // Base business object  { static protected RelationshipMgrTurbo rm = new RelationshipMgrTurbo(); } ///  /// Person class points to one or more orders.  /// Implemented using a relationship manager rather  /// than via pointers and arraylists etc.  ///  public class Person : BO { public string name; static Person() { rm.EnforceRelationship(\"p-\u003eo\", Cardinality.OneToMany, Directionality.DirectionalWithBackPointer); } public Person(string name) { this.name = name; } public override string ToString() { return \"Person: \" + this.name; } public void AddOrder(Order o) { rm.AddRelationship(this, o, \"p-\u003eo\"); } public void RemoveOrder(Order o) { rm.RemoveRelationship(this, o, \"p-\u003eo\"); } public List\u003cOrder\u003e GetOrders() { IList list = rm.FindObjectsPointedToByMe(this, \"p-\u003eo\"); // cast from list of 'object' to list of 'Person'  var result = new List\u003cOrder\u003e(); foreach (var order in list) result.Add((Order)order); // attempts at other simpler ways to cast a whole list  //result = list as List\u003cOrder\u003e; // crash  //result = new List\u003cOrder\u003e(list); // syntax error?  return result; } } ///  /// Order class points back to the person holding the order.  /// Implemented using a relationship manager rather  /// than via pointers and arraylists etc.  ///  public class Order : BO { public string description; public Order(string description) { this.description = description; } public override string ToString() { return \"Order Description: \" + this.description; } public void SetPerson(Person p) { // though mapping is bidirectional, there is still a primary relationship direction!  rm.AddRelationship(p, this, \"p-\u003eo\"); } public Person GetPerson() { // cast from 'object' to 'Person'  return (Person)rm.FindObjectPointingToMe(this, \"p-\u003eo\"); } public void ClearPerson() { rm.RemoveRelationship(this, this.GetPerson(), \"p-\u003eo\"); } } } } Output:\nPerson: Jane has 2 orders The person who ordered Order Description: Clothes is Person: Jane The person who ordered Order Description: Boots is Person: Jane Done! C# Future Directions A generics version of relationship manager would be cool - that way no casting would be required. Presently all calls to relationship manager return objects or lists of objects - which you have to cast to the specific type you actually have stored. You can see this casting in the above example.\nResources   Python Implementation README and GitHub project.\n  Full Python Relationship Manager API documentation.\n  See original andypatterns page\n  Official Relationship Manager Pattern page incl. academic paper by Andy Bulka (this page).\n  ","excerpt":"Abstract Basically describes a lightweight, in-memory Object Database. ‚Ä¶","ref":"/projects/patterns/relationship-manager/","title":"Relationship Manager - Design Pattern"},{"body":"Introduction This article is twenty years old - its ideas are now simplified and clarified at MVCA pattern\nA live demo running in a browser.\nTip for understanding this article: This is arguably the traditional MVC pattern with terminology tweaked and clarified, and updated for ‚Äòmodern‚Äô times where Views are no longer manually drawn but are instead off the shelf GUI widgets or DOM elements.\n Mediator == Controller GUI == View  The Pattern  Comments Comments now disabled due to spam.\nPosted on¬†Jan 18th, 2009 Hi Andy,\nI‚Äôve read your article about the MGM Patterns, it‚Äôs a great pattern.\nHowever, I have a question, could you please show me.\nLet say I have a Textbox (GUI), a business object with only 1 property Text,\na mediator-view as your pattern defined.\nWhen changing Business.Text, this procedure is called:\nprocedure setText(Value: String); begin FText := Value; NotifyChanges; // \\*\\*\\* notify mediator to change Editbox content end; therefore, mediator is notified:\nprocedure BusinessChanged; begin FGUI.Text := FBusiness.Text; // this makes Editbox OnChange fires end; OnChange event of Editbox:\nprocedure Edit1Change(); begin Mediator := FindMediator(Self) Mediator.Business.Text := TEdit(Self).Text; { \\*\\*\\* This line would call Business.setText and make an infinity loop } end; The only method I‚Äôve thought of is let the Mediator modify FText field of\nBusiness object. But in this way, Busniess and Mediator have to be in a same\nunit. Is there another way to solve this problem?\nThanks for your sharing!\nKarr. C.\nPosted by¬†Andy on¬†Jan 18th, 2009 Thanks for your interest in the MGM pattern. Your assumption in the above code is that the Editbox OnChange fires when you programatically set the FGUI.Text, which would cause the event sequence\ngui changes -\u003e mgm notified -\u003e changes model -\u003e model notifies mgm -\u003e mgm modifies gui -\u003e gui changes and so on, infinitely!! See your lines marked *** highlighted lines above.\nHowever the Editbox OnChange fires only seems to fire when the text is altered by the user in the gui. It does not fire when the edit1.text is changed programatically. So there is no loop.\nI tried it in Delphi 6. Here is a sample delphi app that proves it.\nhttp://www.atug.com/downloads/mgmquickproof01.zip\nIt has a cheaper form of mgm which I just whipped up, in order to demonstrate the point.\nP.S. If the event HAD fired, you could\n  temporarily disable the event by rewiring the event handler to Nil before writing to it programatically, then restoring the event handler again (yuk, but possible. You often have to do this when using mgm with treeviews.)\n  provide a way of setting the model data which does not trigger a notification. Make the private data public. Again, yuk.\n  ‚Ä¶ anyway thankfully you don‚Äôt need to do either of these things since Editbox OnChange does not fire when the edit1.text is changed programatically\nHope this helps.\n-Andy Bulka\nPosted by Anon¬†on¬†Jan 21st, 2009 Here is a nice article on MVP pattern and the differences to MVC.\nResources Old link on andypatterns.com\n","excerpt":"Introduction This article is twenty years old - its ideas are now ‚Ä¶","ref":"/projects/patterns/mgm-pattern/","title":"MGM Pattern"},{"body":"Introduction For the original MGM pattern see MGM pattern\nTodoMVC-OO The classic Javascript TodoMVC app implemented without a framework, using plain Object Oriented programming + a traditional MVC design pattern. Distinct, mediating Controller objects are the key to this implementation.\nRunning demo here.\n MVCA Architectural Pattern This project fully implements the TodoMVC specification. It is implemented without a framework, using plain Object Oriented programming + the MVCA architectural design pattern:\nWhilst the MVC (Model View Controller) pattern is commonly and glowingly referred to, implementations can vary widely. Most documentation on MVC, including the official wikipedia article is vague on definitions and details. This TodoMVC-OO project uses the MVCA pattern (formerly the MGM pattern) which is a clear and unambiguous interpretation of MVC, with the following key ideas:\n The View means a modern GUI framework, and therefore is usually already available to be used by the programmer. One or more Controllers mediate between the View and the rest of the Application, listening for GUI events. Nobody else knows about the View. The Model is traditional data, may contain some business logic, and may broadcast events when its attributes change. The Application owns the model(s), holds view state and contains some business logic methods. An Eventing system is needed, traditionally Observer pattern but the stronger decoupling and the proper event objects of the Publisher-Subscriber pattern is preferred.  Thus MVCA simply means ‚ÄúModel View Controller Application‚Äù - all four roles are necessary to any implementation.\n The above diagram was generated semi-automatically from Javascript source code residing in GitHub using GitUML. Click here for more diagram detail as a¬†.svg and the ability to zoom.¬† View this actual diagram 181 on GitUML.  MVCA In Detail Let‚Äôs go through the four parts of the MVCA pattern, which is precisely adhered to by this TodoMVC-OO implementation. Actually there is a fifth important part - the eventing system - which glues it all together - let‚Äôs look at the Model first.\nModel The Model is traditional, may contain some business logic, and may broadcast events when its attributes change.\nBy traditional, I mean the Model does not know about anything else except perhaps other models. Its the core model of your data, the domain of the what the application is all about. In the case of the Todo application, it is a collection of Todo items, which can be marked completed.\nclass TodoItem { constructor(title, id, completed) { this._title = title == undefined ? \"\" : title; this._completed = completed == undefined ? false : completed; this.id = id == undefined ? util.uuid() : id; // no getter/setter needed  } get title() { return this._title; } set title(v) { this._title = v; this.dirty() } get completed() { return this._completed; } set completed(v) { this._completed = v; this.dirty() } get as_dict() { return { id: this.id, title: this.title, completed: this.completed } } delete() { notify_all(\"deleted todoitem\", this) } dirty() { notify_all(\"modified todoitem\", this, {during_load: false}) } } The Model is usually broken into many smaller interconnected models in an attempt to reflect the real world domain being implemented as software. The Model can be implemented as mere objects in memory or a full-fledged database model, or a ORM mapping between the two. In our case, we have a pure memory model, which gets persisted into local browser storage as JSON.\nYou will find that some ‚Äòmodel‚Äô concepts are more about how the information is presented in the GUI, thus I recommend these are kept as attributes of the Application class, and referred to as the view state or view model. The attribute filter is an example of such view state. The Application class can also hold collections of models which is what we do in this project:\nclass Application { constructor(config) { this.todos = [] // model collection  this.filter = 'all' // view model, options are: 'all', 'active', 'completed'  ... } The model can be fat or thin - a fat model will have more business logic in the model. A thin model will most business or application logic in the Application class, treating the model as just data structures.\nFinally, the Model needs to participate in the internal eventing system. Whenever an attribute changes it should send out a notification event - this is why most attributes of our TodoItem class are accessed via getter and setter methods. For example setting title or completed will trigger an internal event to whoever may be listening. This internal eventing mechanism is how Controllers know to update the GUI with updated model information.\nView The View means a modern GUI framework, and as such is already available to be used by the programmer. In our case, our modern GUI framework is the browser DOM which you can build in HTML:\n\u003cinput id=\"toggle-all\" class=\"toggle-all\" type=\"checkbox\"\u003e then Controllers use the GUI native eventing system to listen for interesting events\nthis.gui.$toggle_all.on('change', handler) Controller The Controller is the most interesting aspect of¬†MVC.\nIn many software designs, the Controller isn‚Äôt necessarily a single thing. A bunch of stray GUI event handler functions are in reality, part of the ‚Äòcontroller role‚Äô. Code that copies data from the model into the GUI/DOM is also part of the Controller role. I feel the challenge of GUI architectures is to tame the role of Controller into some semblance of coherance and symmetric organisation. Which is why MVCA prescribes creating Controller classes.\nIn TodoMVC-OO we have a Controller class ControllerTodoItem and instantiate one per TodoItem model instance. That‚Äôs arguably a lot of controller instances, but this approach allows fine grained updating of the DOM. In contrast, the Jquery version of TodoMVC rebuilds the entire todo DOM on each refresh - something that might become inefficient for non-toy apps.\nIn TodoMVC-OO we have a Controller class ControllerHeader for looking after the header part of the GUI and ControllerFooter for looking after the footer area, which is where the filter buttons are and the count of uncompleted todo items is displayed. The number of Controllers you create is up to you: one Controller per GUI element for fine grained updates, a more relaxed approach of one Controller per related group of GUI elements (my preference) or arguably even one Controller for all GUI elements! I go into more academic detail on this topic in my MGM pattern paper.\nBy clearly defining what a mediating Controller is, and organising our app into different sensible controllers, we tame our design and prevent it from turning into spaghetti.\n  View events only talk to Controllers:\n View events (‚Äògui events‚Äô e.g. via .on('click', ...)) go to one or more Controllers. Controllers update the View, usually in reponse to an ‚Äòinternal event‚Äô notification.    The Controller talks to the rest of the system:\n Accesses App view state. Calls App business logic methods. Modifies the Model directly.    The Controller listens for ‚Äòinternal events‚Äô broadcast from Model \u0026 App.\n  Whilst that may seem like a lot to understand, its basically saying Controllers talk to the GUI - nobody else does. Controllers then call into the rest of the system to get things done\nImportantly, we must resist putting business logic into the Controller, simply let the controller call the Application to do what needs to be done. The Controller should do the minimal possible work, mediating and translating between the View and the rest of the system (the App + Model).\nApplication The role of the Application is also important and often overlooked/undocumented. The Application owns the Model, and looks after persisting it. The Application can listen for internal Model events.\nWhilst it is fine to wire Controllers directly to model instances, you will also need the Application to hold ‚Äúview state‚Äù e.g. like the state of the active ‚Äúfilter‚Äù in this Todo application. The Application is a centralised class, a kind of hub - to hold higher level business logic and more complex model manipulations. The Application class‚Äôs functionality can of course be composed of smaller pieces as software grows more complex but a class called Application should always still exist.\nEventing System Eventing is an important consideration in decoupling models from controllers, and to facilitate abstract communication between objects.\nTwo eventing systems should be distinguished:\n GUI native: The native eventing system of the GUI Framework e.g. DOM .on('click', ... Internal: Your choice of an application system wide eventing system e.g. Publish-Subscribe e.g. document.addEventListener(\"hello\", (event) =\u003e { ... })  Both eventing systems are used in the TodoMVC-OO implementation. As you can see in the diagram above, DOM eventing reaches the Controllers, but no further. The remaining eventing is internal.\nHere is a Literate Code Map of the event flow of TodoMVC-OO. Events are reified as coloured objects, each different event gets a different colour. TodoMVC-OO event flow.\n The above diagram was generated semi-automatically from Javascript source code residing in GitHub using GitUML. Click here for more diagram detail as a¬†.svg and the ability to zoom.¬† View this actual diagram 134 on GitUML.  The eventing pattern depicted here is Publisher-Subscriber where real event objects are ‚Äòbroadcast‚Äô into the ether/event bus/system/whatever - allowing any code in the system to subscribe and respond - the point is, the code emitting the event does not have references to receiver object/methods.\nThe Javascript built in Publisher-Subscriber eventing approach is more flexible and powerful than the Observer pattern since the Observer pattern requires observers to know about and subscribe to Subject objects, which is not always possible or convenient. More dicussion on the differences can be found in this article and on Stackoverflow. Thus we use Publisher-Subscriber eventing (event name ‚Üí object method) rather than the traditional Observer pattern (object ‚Üí object) approach.\nI used to be a fan of the traditional Observer pattern but in my later years find the Publisher-Subscriber pattern to be simpler and more powerful - plus Publisher-Subscriber is built into Javascript you simply document.addEventListener(\"hello\", (event) =\u003e { ... }) to listen and document.dispatchEvent(new CustomEvent(event_name, { detail: {from: from, data: data } })) to notify all.\nThe Javascript built in Publisher-Subscriber eventing system is used as the internal eventing system of this TodoMVC-OO implementation.\nApplication Bootstrapping To get things running, some bootstrapping code will create an instance of the Application which in turn creates all the Controllers and loads the Model. The bootstrapping in TodoMVC-OO is done in app.js which creates an instance of Application which is defined in application.js.\n(function (window) { let config = {...} new Application(config) })(window); Notice that a config object with a list of callback methods is passed into the Application.\nGiving the Application class knowledge of individual Controller classes and all the GUI view elements they need is arguably contaminating the Application class with too much GUI view and Controller knowledge.\nThe solution I use is to pass the Application a config object which contains a bunch of callbacks. Each callback function will magically create a Controller instance, wired to look after its GUI elements. Each callback function hides, within itself, references to the DOM - which we don‚Äôt want the Application to have. In this way, the bootstrapping code and the Controller code are the only parts of the architecture that know about the View specifics (which we want to restrict).\nThus whenever the Application needs to instantiate a Controller (e.g. each time a TodoItem is created) it calls a config callback function. Another example is during bootup - some permanent Controllers need to be created, like the Controller looking after the header area, so the Application calls this.callback_config.cb_header(this) which creates an instance of the ControllerHeader wired to $('.new-todo') and $('.toggle-all'). The Application only needs to know the callback function names and thus remains pure.\nNotice in the config object below that each callback refers to the view through JQuery syntax e.g. $('ul.todo-list') and passes these references into the contructor of the Controller:\nlet config = { // Callback to create the todo item controllers - are added as needed  cb_todo: function (app, todo) { new ControllerTodoItem( app, todo, { $todolist: $('ul.todo-list') } ) }, // Callbacks to create the permanent controllers  cb_header: function (app) { new ControllerHeader( app, { $input: $('.new-todo'), $toggle_all: $('.toggle-all') } ) }, cb_footer: function (app) { new ControllerFooter( app, { $footer: $('footer'), $footer_interactive_area: $('.footer') }) } } Of course the Controller itself will have further references to View DOM elements, however these references should be based on searching within the outer DOM element passed to the Controller - thus achieving some degree of ‚Äòcomponent-isation‚Äô and re-use. For example the same Controller could be used to look after different DOM elements with different element id‚Äôs.\nTodoMVC-OO Conclusion This project fully implements the TodoMVC specification and is implemented without a framework, using plain Object Oriented programming + MVCA architectural design pattern, as described above.\nRunning demo here.\nImprovements In this implementation, I notice that footer renders too early rather than right at the end of the initial render. Its just a subtle flash of the footer when the page is initially redrawn, but I‚Äôd like to correct this.\n Resources  Official TodoMVC project with other TodoMVC implementations (e.g. Vue, Angular, React etc.) TodoMVC-ECS - My ‚ÄúEntity Component System‚Äù implementation of TodoMVC GUI Showdown MVCA another example of an app implemented using the MVCA architecture (Javascript, open source) MGM pattern (older version of MVCA, presented at a Patterns Conference)  Diagramming  GitUML diagramming used for this project Literate Code Mapping diagramming used for this project  Credit Created by Andy Bulka\nNote: This project is not not officially part of the TodoMVC project - as it is does not use a MVC framework library, nor does it meet the criterion of ‚Äúhaving a community‚Äù around it. On the other hand, perhaps a pattern is equivalent enough to a framework - after all there is a plain Javascript TodoMVC implementation officially available using ad-hoc techniques. Plus, there has been a ‚Äúcommunity‚Äù around the Object Oriented MVC pattern for decades now - hasn‚Äôt there? üòâ\n","excerpt":"Introduction For the original MGM pattern see MGM pattern\nTodoMVC-OO ‚Ä¶","ref":"/projects/patterns/mvca-pattern/","title":"MVCA Architectural Pattern"},{"body":"Introduction The Transformation Interface is both a design pattern and an architectural pattern. It describes an interface or layer, which offers services to transform an object into another format and back again. A pair of methods on some class e.g. load/save are often the signature of a Transformation Interface.\nThe Pattern  ","excerpt":"Introduction The Transformation Interface is both a design pattern and ‚Ä¶","ref":"/projects/patterns/transformation-interface/","title":"Transformation Interface Design Pattern"},{"body":"Developing a Layout Algorithm for UML diagrams Intro Presented to the Melbourne Patterns Group, Wednesday 6th April¬†2011 6:30 PM\nThe Problem: Untangling UML Diagrams Terms  Nodes ‚Äì these are the shapes/rectangles Edges ‚Äì these are the lines connecting the shapes  Background  My UML tool is written in Python Existing layout libraries for e.g. python PyGraphviz has no windows port so I wrote my own Layout is reasonably hard to implement ‚Äì academic papers are very complex and deal in a lot of math DIRTY SECRET OF ACADEMIA - Most Layout algorithms only deal with ‚Äòpoints‚Äô and don‚Äôt take into account real width and height  Thus for any real world use (unless dealing with network and particle visualisation where each node is the same size/shape), it seemed to me that one needs to run an overlap removal algorithm after the layout to remove shape overlaps.\nOverlap removal algorithm needs to minimise shape movement in order to respect the layout results\nWhat I developed  I used a ‚Äòspring layout‚Äô adapted from java and javascript I developed my own overlap removal algorithm Developed a GUI sandbox test app for development  Overlap Removal - Before and After   before\n    after applying layout\n  Unit Testing Extensive unit tests were created to keep on top of the layout algorithm results. A word document containing annotated screenshots for each test helped me enormously.\n  an overlap removal use case which became a unit test\n  Layout / persistence format was created for creating layout scenarios\n{'type':'node', 'id':'D25', 'x':6, 'y':7, 'width':159, 'height':106} {'type':'node', 'id':'D13', 'x':6, 'y':119, 'width':119, 'height':73} {'type':'node', 'id':'m1', 'x':170, 'y':9, 'width':139, 'height':92} Unit Testing Brittleness Avoided Loose tests using (e.g. I created a function called ensureYorder() etc) were created so that the tests were not too brittle. Slight variations in position are ignored.\nView this unit test file at the Pynsource GitHub repository tests/test_overlaps1.py. Here is an example unit test:\ndef _LoadScenario3(self): self.g.LoadGraphFromStrings(TEST_GRAPH3) def test3_5InsertedVerticallyTwoPushedDown(self): self._LoadScenario3() # move m1 to the left node = self.g.FindNodeById(\"m1\") node.left, node.top = (6, 4) d97 = self.g.FindNodeById(\"D97\") oldD97pos = (d97.left, d97.top) # assert m1 has been inserted vertically - two pushed down were_all_overlaps_removed = self.overlap_remover.RemoveOverlaps() self.assertTrue(were_all_overlaps_removed) self.assertEqual(2, self.overlap_remover.GetStats()[\"total_overlaps_found\"]) self.assertTrue(self._ensureYorder(\"m1\", \"D25\", \"D13\")) self.assertTrue(self._ensureXorder(\"m1\", \"D97\", \"D98\")) self.assertTrue(self._ensureXorder(\"D25\", \"D97\", \"D98\")) self.assertTrue(self._ensureXorder(\"D13\", \"D97\", \"D98\")) self.assertEqual(oldD97pos, (d97.left, d97.top)) # ensure D97 hasn't been pushed Running the tests:\n  An example test run\n  Having a huge bank of unit tests helped in refactoring, too. Imagine testing all the necessary scenarios by hand!\nThe final Results were pretty good!\n  A UML diagram after overlap removal\n  Design Patterns Used Memento  Memento was used to remember graph layout positions and then compare mementos to see if anything had ‚Äòchanged‚Äô and thus drop out of the Spring layout algorithm early Memento was used to save/restore layouts in my test GUI ‚Äì assigned to keys 0..9  Blackboard Blackboard pattern used to run layout several times and figure out which was the best, cleanest result using multiple criteria. Each run is a ‚Äòsnapshot‚Äô\nSnapshot 1 [6] LL 0 NN pre rm overlaps 5 LN 0 scale 1.6 bounds 23 (500, 473) \u003c--- Snapshot 2 [4] LL 0 NN pre rm overlaps 5 LN 1 scale 1.4 bounds 30 (570, 537) Snapshot 3 [5] LL 0 NN pre rm overlaps 6 LN 2 scale 2.0 bounds 17 (444, 393) Snapshot 4 [2] LL 0 NN pre rm overlaps 4 LN 2 scale 1.4 bounds 34 (648, 537) Snapshot 5 [3] LL 0 NN pre rm overlaps 5 LN 4 scale 2.0 bounds 21 (427, 508) Snapshot 6 [1] LL 0 NN pre rm overlaps 10 LN 5 scale 2.0 bounds 18 (485, 379) Python goodness helped in this ‚ÄòAI‚Äô smartness\ndef sortfunc(d): # this does the thinking! return (d['LL'], d['LN'], d['bounds_area_simple'], -d['scale'], d['NN_pre_OR']) Future  ‚ÄúLine over node‚Äù overlap was abandoned as it started to get really complex with a lot of trigonometry and perhaps this area needs a more academic approach Non straight lines and line routing is probably the better direction Adding an understanding of UML semantics is another direction to research, so that e.g. base classes are above derived classes etc.  Overlap Removal Server In 2020 I needed to expose the overlap removal code as an API for javascript to use.\nHere is that small research sub-project https://github.com/abulka/pynsource/tree/master/Research/overlap_removal_server\nResources Code and Links  Overlap removal code is Python, open source Part of my python UML tool PyNSource: Reverse engineer python source code into UML - display UML as Ascii art or PlantUML diagrams in a proper diagramming visual workspace.  Slides on Scribd UML Graph Layout - Andy Talk - March 2011\nSlides as HTML  The problem of laying out UML Spring Layout Mapping¬†layout to Real World OGL MVC Overlap Removal Unit tests and unit test diagrams Memento Design Pattern Blackboard Design Pattern \u0026 Injecting sorting function Future..   Slides as Pdf download View as pdf\n Images Sample Images   before\n    after applying layout\n  ","excerpt":"Developing a Layout Algorithm for UML diagrams Intro Presented to the ‚Ä¶","ref":"/blog/2011/04/06/uml-layout/","title":"UML Layout"},{"body":"Ever wanted to create a ‚Äúdirect manipulation‚Äù program where you select various tools and manipulate stuff on a workspace?¬†These sorts of applications are quite difficult to build due to the many possible combinations of behavior that is needed.¬†Every tool must know what to do with each type of object.¬†How do we manage this sort of complexity?\n How do you represent shapes? How do you represent tools? How do tools and shapes interact? How do you enhance the editor with new shapes and tools?  Tooled Composite - Architectural Design Pattern The GOF (gang of four) author John Vlissides documented this pattern in this paper.\nTooled Composite Pattern UML\nPresentation Here is a presentation I gave at the Melbourne Patterns Group about using this pattern in the implementation of the software Rationale where I was Chief Software Architect.¬†It ended up being a success, though we did learn a few things along the way (see below).\n What we learned Whilst implementing this pattern basically saved our bacon, in terms of getting the job done, having the pattern rely on visitor so much did add a layer of complexity that was tiresome to maintain.¬†Here are some some things we learnt after living with this pattern for a few years:\n   Classic approach Possibly a more Practical approach     visitor design pattern use RTTI (or equivalent e.g. have each shape return a shapeType enum) for better comprehensibility.   3D table of possibilities, with events, shapes, tools on each axis. table too sparse and complex, so just code for the cases you want.   some blend of visitShape() / visitEdge() etc methods and mouse event methods, within each tool skip most of the visit methods and do the logic in the mouse handling methods.¬†Generalise the mouse handling into one event (mouseAction) and use if statements to catch the situations of interest.¬†You know what the current shape is by having a pointer to it (set up for you by the tool or something).   use tooled composite for all interactivity have pockets of interactivity where a component takes over and looks after the gui instead of doing everything the tooled composite way (more explanation below)    With regards to the last point, what we were doing was considering the idea of creating self contained components that had their own little world inside themselves, that was totally independent of the tool/visit system.¬†This way we didn‚Äôt have to use this architectural pattern for absolutely everything, since that was getting really intricate and tedious.¬†We considered for example building a box (shape with text in it with various sub editable parts like titles and radio buttons) editor using the regular .NET component system and use their well understood way of handling events, and editing etc. - rather than coding visitors and miniscule tool interactions.¬†So the idea was that as we went into say, ‚Äúedit mode‚Äù, we would switch away from the tooled composite pattern and into the world of .NET - just during the edit.\nFinal Verdict Make no mistake, we desperately needed the Tooled Composite Pattern approach to hold everything together, and to be the default system in play.¬†The .NET component approach (described above) definitely wasn‚Äôt suited to a deep and complex drawing tool like Rationale, with zooming, mini maps, panning, layout algorithms etc. In fact we found in experiments / spikes of a fully .NET component approach that .NET events would fire all over the place causing too much screen refreshing.¬†So in the end a we used Tooled Composite for mostly everything, and dropped into .NET components only when needed eg. the text editor that you get when you double click on a workspace box in order to edit the text inside it was a pure .NET text control.¬†We never got to push this hybrid approach any further - we wanted to write a super fancy text editor component (with hover zones, places for specifying urls and bold headings etc.) ourselves purely in .NET - we just didn‚Äôt have the time - thus we mostly stayed completely within the classic Tooled Composite Pattern.¬†And I‚Äôm not sure what we would have done without it!\n","excerpt":"Ever wanted to create a ‚Äúdirect manipulation‚Äù program where you select ‚Ä¶","ref":"/blog/2006/03/01/tooled-composite-pattern/","title":"Tooled Composite Pattern"},{"body":"Relational databases and OO memory models use different paradigms.¬†Mapping between one and the other is often necessary but usually ends up being fiddly unless an auto-mapping ORM tool is used.\nHow an ORM works Let‚Äôs face it - a lot of developers prefer to just code classes - that‚Äôs what OO is all about.¬†Having then to persist those classes into tables creates all sorts of fiddly mapping code.¬†If you don‚Äôt need to persist into tables - fine.¬†But if you do need to persist into tables, one way to reduce your workload is to use a tool like SQLObject - you simply write your code in a certain way and the tables are automatically maintained.\n Each class becomes a table. Each attribute on a class is a column in a table.  The ORM tool automatically causes the setting of attributes on objects to have a wonderful side effect: the values are written to the database table.¬†And conversely, pulling information out from your object triggers the appropriateSQL calls to retrieve the information from the table.¬†You don‚Äôt have to deal with sql syntax yourself. However you can take advantage of the fact that you now have a sql backend, to make sql-like queries - thus you can save coding effort.¬†You have all the power of SQL at your disposal now, you might as well use take advantage of it!¬†You don‚Äôt have to use precise SQL syntax but you need to use something very much like it\nORM using SQLObject In SQLObject (a Python library) you would write things like:\nps = Person.select(\"\"\"address.postcode LIKE '3186'\"\"\", clauseTables=['address']) print list(ps) ORM (object relational mapping) tools usually let you choose what style of ‚Äòback-end‚Äô database to use with a configuration switch - e.g. develop on sql-lite and deploy on mysql - all without changing any of your code.\nPresentation  Object Relational Mapping Pattern - using Sql Object - slideshare\nExample Before using SQLObject This is an example of some Person, Cubicle and Order classes. Persons live in Cubicles and can place one or more orders. No database activity is involved here - its all just regular python code with pointers and lists.\n# BEFORE the use of a database class Cubicle: def __init__(self, location=\"unknown\"): self.location = location self.occupant = None def SetOccupant(self, person): # Evict any previous occupant if self.occupant: self.occupant.cubicle = None self.occupant = person # New occupant wired in person.cubicle = self # back pointer class Person: def __init__(self, firstname, lastname): self.firstname = firstname self.lastname = lastname self.cubicle = None self.address = None self.orders = [] self.addresses = [] def AddOrder(self, order): self.orders.append(order) # one to many order.person = self # back pointer def SetAddress(self, address): self.addresses.append(address) # many to many address.residents.append(self) # back pointer (note the 'append' cos many to many) class Order: def __init__(self, orderNumber, description): self.orderNumber = orderNumber self.description = description class Address: def __init__(self, street, suburb, postcode): self.street = street self.suburb = suburb self.postcode = postcode self.residents = [] # Test One to one cubicle1 = Cubicle(\"North Wing D4\") tom = Person(firstname=\"Tom\", lastname=\"Jones\") cubicle1.SetOccupant(tom) assert cubicle1.occupant == tom # Test One to many o1 = Order(orderNumber=\"12345\", description=\"new ipaq\") o2 = Order(orderNumber=\"12346\", description=\"new ipod\") tom.AddOrder(o1) tom.AddOrder(o2) assert len(tom.orders) == 2 assert o1 in tom.orders assert o2 in tom.orders # Test Many to many angelina = Person(firstname=\"Angelina\", lastname=\"Jolie\") a1 = Address(\"Fox Studios\", \"California\", 3186) # tom and angelina both work here a2 = Address(\"Brads Place\", \"Manhattan\", 40004) angelina.SetAddress(a1) angelina.SetAddress(a2) tom.SetAddress(a1) assert a1 in angelina.addresses assert angelina in a1.residents assert angelina in a2.residents assert tom in a1.residents assert tom not in a2.residents ################## Now do some more complex manipulations ######### # Move angelina into the North Wing D4 cubicle and  # move Tom into a new cubicle cubicle1.SetOccupant(angelina) assert cubicle1.occupant == angelina assert tom.cubicle == None cubicle2 = Cubicle(\"West Wing D5\") cubicle2.SetOccupant(tom) assert tom.cubicle == cubicle2 print 'Done!' Output:\nDone! Code - After SQLObject Now for the fascinating transformation. We refactor the code to use SQLObject and we end up with the same logic, but as a bonus we have persistence in a sql database. And its not so hard either!\n# AFTER - the database version - notice we import sqlobject from sqlobject import * from sqlobject.sqlite import builder; SQLiteConnection = builder() conn = SQLiteConnection('person.db', debug=False) class Cubicle(SQLObject): _connection = conn location = StringCol(length=20, default=\"unknown\") occupant = ForeignKey('Person', default=None) def SetOccupant(self, person): # Evict any previous occupant if self.occupant: self.occupant.cubicle = None self.occupant = person # New occupant wired in person.cubicle = self # back pointer class Person(SQLObject): _connection = conn firstname = StringCol(length=20) lastname = StringCol(length=20) cubicle = ForeignKey('Cubicle', default=None) orders = MultipleJoin('GiftOrder') addresses = RelatedJoin('Address') def AddOrder(self, giftOrder): #self.orders.append(giftOrder) # one to many # SQL OBJECT doesn't need this giftOrder.person = self # back pointer ** becomes the primary info sqlobject goes on def SetAddress(self, address): #self.addresses.append(address) # many to many # SQL OBJECT doesn't need this #address.residents.append(self) # back pointer (note the 'append' cos many to many) # SQL OBJECT doesn't need this address.addPerson(self) # SQLobject created this \"addWHATEVER\" method for us class GiftOrder(SQLObject): _connection = conn orderNumber = IntCol() description = StringCol() person = ForeignKey('Person', default=None) class Address(SQLObject): _connection = conn street = StringCol(length=20) suburb = StringCol(length=20) postcode = StringCol(length=20) residents = RelatedJoin('Person') #def _init(self): # SQLObject._init(self, *args, **kw) # self.postcodesDict = {'2323':'Brighton','22222':'Werribee'} Cubicle.dropTable(True) Cubicle.createTable() Person.dropTable(True) Person.createTable() GiftOrder.dropTable(True) GiftOrder.createTable() Address.dropTable(True) Address.createTable() # Test One to one cubicle1 = Cubicle(location=\"North Wing D4\") tom = Person(firstname=\"Tom\", lastname=\"Jones\") cubicle1.SetOccupant(tom) assert cubicle1.occupant == tom # Test One to many o1 = GiftOrder(orderNumber=12345, description=\"new ipaq\") o2 = GiftOrder(orderNumber=12346, description=\"new ipod\") tom.AddOrder(o1) tom.AddOrder(o2) assert len(tom.orders) == 2 assert o1 in tom.orders assert o2 in tom.orders # Test Many to many angelina = Person(firstname=\"Angelina\", lastname=\"Jolie\") a1 = Address(street=\"Fox Studios\", suburb=\"California\", postcode=\"3186\") # tom and angelina both work here a2 = Address(street=\"Brads Place\", suburb=\"Manhattan\", postcode=\"40004\") angelina.SetAddress(a1) angelina.SetAddress(a2) tom.SetAddress(a1) assert a1 in angelina.addresses assert angelina in a1.residents assert angelina in a2.residents assert tom in a1.residents assert tom not in a2.residents ################## Now do some more complex manipulations ######### # Move angelina into the North Wing D4 cubicle and # move Tom into a new cubicle cubicle1.SetOccupant(angelina) assert cubicle1.occupant == angelina assert tom.cubicle == None cubicle2 = Cubicle(location=\"West Wing D5\") cubicle2.SetOccupant(tom) assert tom.cubicle == cubicle2 # Now SQLOBJECT lets us do other magic things, that leverage relational db technology p = Person.get(1) print p #ps = Person.select(Person.q.firstName==\"John\") #print list(ps) #ps = Person.select(\"\"\"address.id = person.id AND # address.postcode LIKE '40004%'\"\"\", # clauseTables=['address']) ps = Person.select(\"\"\"address.postcode LIKE '3186'\"\"\", clauseTables=['address']) print list(ps) print 'all people' ps = Person.select() print list(ps) print 'Done!' Output:\nWhat sort of tables are created? You can browse the resulting database tables (in this case sqllite tables) using the SQLite Database Browser. Here are some screenshots of the tables we have created:\nthis is the table structure:\nAll the above tables and content were created by the Python code!\nAlternatives You may also be interested in Sqlalchemy for Python which is very powerful and flexible, perhaps getting a bit complex.¬†Django of course has a built in ORM and is much easier to use, though you can only use it in Django web apps.\nThen there are ORM frameworks for Java like hibernate and many, many others.¬†Just google for ORM.¬†And if you are into .NET then the ‚Äúlow hanging fruit‚Äù solution of LINQ is worth looking at.\n The point of this article has been to get you to see the essence of what an ORM does, with the minimal amount of code.\n ","excerpt":"Relational databases and OO memory models use different paradigms. ‚Ä¶","ref":"/blog/2005/07/01/orm-pattern/","title":"ORM Pattern"},{"body":"This is an exploration of how to swap implementations of objects within our software architectures using patterns like the Interface, Factory, Strategy, Proxy, Adapter, and finally to the full blown Bridge Design Pattern.¬† This article was formerly known as The ‚ÄúRoad to the Bridge‚Äù and as ‚ÄúStrategy to Bridge‚Äù\n The problem We want to be flexible in our architecture.¬†We want to be able to swap implementations of objects/classes easily e.g. between using class A or class B.¬†We want to:\n Build to anticipate and celebrate change. Program to interfaces, not implementations..  Some broad solutions Let‚Äôs examine the range of solutions -¬†showing the story of how to bind to two different implementations of the same interface - simple ways and more complex ways. Specifically how we can choose between:\n compile-time binding (one or the other is chosen by compiled code) factory based binding (one or the other is returned by a factory) dynamic binding using an intermediary object  where #3 is achieved using Strategy, Adapter and Proxy, which ultimately leads us to using the Bridge Pattern.\n This journey strikes me as a powerful way of looking at a deep and common problem (building to embrace change), and that also unites multiple patterns under the one theme. Given programmers love the ideal of ‚Äòprogramming to interfaces‚Äô and being able to swap in different implementations, this story will show how to do it at many different levels and in fact how many of the classic GOF design patterns are all about helping us to achieve it.\n Interface pattern Interface, compile time choice Alternative implementations of an interface. Instantiate one or the other implementation of that interface. The code that uses the object is unaware of which object it is using. ‚ÄúProgram to an interface‚Äù\nWorker o = new A() // Worker o = new B() o.DoSomething() Here the choice is at compile time, by commenting out one or the other instantiation.\nInterface, dynamic run time choice Same solution except choose particular implementation dynamically at runtime using a flag.\nif flag Worker o = new A() else Worker o = new B() o.DoSomething() // we don't know if its an A or a B. Everything works ok. Factory Create A or B at runtime by asking another class to create the concrete object for us.¬†Pass in the flag to the factory or let the factory decide for itself which implementation we want.\nFactory class is the only class to refer to concrete products. The client refers to the interface/abstract class only.\nWe are still talking directly to the concrete object (either an A or a B).\nThere are a number of factory method variants:\nSimple Super Dumb Factory Encapsulates the ‚Äúdynamic run time choice‚Äù solution discussed in the beginning of this talk. Benefit is that the¬†conditional logic containing the if statement is hidden and possibly centralized in a factory class.\nFactory class is the only class that refers directly to concrete products. Client refers only to interface/abstract class.\nThe choice is made via conditional code.\nFactory f = new SimpleFactory() Worker o = f.CreateWorker() o.DoSomething() // we don't know if its an A or a B. Everything works ok. Registry Based Factory Maintains a registry of mappings between strings (or any type of key e.g. objects, class references, numbers etc.) and class references.¬†Benefit: more generalized, no if statements.¬†Factory class is the only class that refers directly to concrete products. Client refers only to interface/abstract class.\nThe choice is made via registry key.\nkey = 'worker a' // in setup code somewhere Factory f = new RegistryFactory() Worker o = f.CreateWorker(key) o.DoSomething() // we don't know if its an A or a B. Everything works ok. GOF Factory Method Assumes the client already has an instance of some class which needs either a A or B version of a worker class.¬†Each alternative instance of¬†the existing class overrides a create method differently, each instantiating a different concrete product - typically one matching their own functionality. Benefit: no class reference language facilities required.¬†Factory class is the only class that refers directly to concrete products. Client refers only to interface/abstract class.\nThe choice is made via polymorphic override.\nNote that the choice as to which Work Manager (MgrA or MgrB) to instantiate in the first place is going to be an issue, but is not the point of this example.¬†The point is that once you have a particular brand of work manager, then you will get a related brand of of worker via the suitably overriden CreateWorker factory method.\nWorkManager f = new MgrA() // done somewhere in setup Worker o = f.CreateWorker(key) o.DoSomething() // we don't know if its an A or a B. Everything works ok. There will be parallel hierarchies, e.g. the WorkManager and the Worker hierarchies closely match, with A and B versions of their subclasses.¬†Start to think of a family of classes.\nMy further thoughts, including a more detailed example of Factory Method here.\nAbstract Factory Abstract factory similar to factory method, in that there is something being overridden.\nAbstract factory is the same as factory method, except there is¬†more than one Creation method.¬†E.g. CreateWorker, CreateAdministrator, CreatePoliceman - such that the class containing the factory methods might as well become a sole purpose class for dispensing these related classes.\nThe abstract factory is a mere mechanism for delivering A versions of B versions.¬†E.g. Client wants A version of products\nClient programs against interfaces thus can switch between A or B.¬†Specifically, the client only talks to¬† IAbstractProductFactory IProduct1 IProduct2 IProduct3  IAbstractProductFactory f = new ProductFactoryVersionA() // choice is made at compile time, via factory method (run time) via strategy (runtime) IProduct1 p1 = f.CreateProduct1() IProduct2 p2 = f.CreateProduct2() IProduct3 p3 = f.CreateProduct3() All products p1, p2, p3 are in the above example A versions, and compatible with each other.\nMy further thoughts on Abstract Factory here.\nIndirection Patterns Getting to implementation A or B via intermediary.\nRather than instantiate A or B and refer to them directly (albiet via a flexible interface variable), another approach is to refer to the same object all the time and hide the switching behind that object.\nNow, because what is behind the intermediate object is hidden (and rightly so), you no longer need to program to the Strategy interface.\nIf you want to still program to an interface (good idea) then program to the Intermediary interface.¬†If you want to run free and wild, program to the intermediary object api.\nVariants are as follows:\nProxy Pattern v1 A methodless indirection using ‚Äúdemeter‚Äù referencing.\nResponsibility of the client to know the API of the strategy.¬†So still programming to the strategy interface.¬†You have to since the intermediary has no methods, or rather, has no methods specifically related to accessing the A \u0026 B classes.\no = new Intermediary() o.SetStrategy(new A()) // done in setup somewhere, or via a factory or via dependency injection framework o.impl.DoSomething() Strategy Pattern Proper Strategy.\no = new Intermediary() o.SetStrategy(new A()) // done in setup somewhere, or via a factory or via dependency injection framework o.DoSomething() later you can switch the strategy without the client code caring.\no.SetStrategy(new B()) o.DoSomething() // different behaviour or different implementation occurs Strategy with a touch of the Adapter pattern If your implementation has a slightly different API than the one your client code wants to use, then you can adapt it at the same time as you are strategizing‚Ä¶\nProxy v2 - going all the way If your only have the same methods in your intermediary object as you have in your implementation, then you can have the intermediary inherit from the abstract implementation interface.¬†This turns the pattern into proxy, and lets you optionally, program to the Strategy interface again.\nThe proxy, whilst inheriting from Strategy, can also implement extra methods, though this is diverging a little from the intent of Proxy.\nAn alternative to inheritance, the proxy can implement the interface of the Strategy class, and get some similar polymorphic substitutability benefits.\nBridge Pattern This is still a variant on accessing different behaviour via an intermediary.\nBridge is just strategy with a oversized lhs context.\nSame as strategy except there is\n Massive subclassing going on on the lhs (the ‚Äòcontext‚Äô side). The nature of the lhs methods are more compositional, adaptive and far reaching (not just a simply strategy delegation)  Massive subclassing There is massive subclassing going on in the lhs. context.\nThe reason is that you are wanting lots of methods and lots of functionality, lots of classes.¬†E.g. you want to have a GUI or DB subsystem, not just a single strategy.\nlhs and rhs methods What is the nature of the lhs and rhs methods?\nTypically rhs (implementation/driver) calls are more primitive, and one lhs method will call the rhs. many times. e.g. see the DoTalk() method, above.\nThe lhs methods can be diverse, comprising\n lhs method simply calls rhs method. Method names can change or be the same. Simple delegation with no extra work. lhs methods more complex and adapt and do extra lines of code as needed Lots of logic in the lhs methods and may have associated helper classes.¬†But in the end they call stuff on the intermediary api.  Insulated from change.¬† Allows lhs and rhs to vary independently.\nClient is insulated from changes. Should not talk talk to implementation, even if it is the abstract implementation interface because the abs impl. may change. If the abstract implementation interface does change then this affects only the Intermediary but not the client code.¬†Client code should thus only talk to intermediary.\nSimilarly, if you change the Intermediary API, then only the client is affected - the r.h.s. (the abstract implementation interface and concrete implementations) are not affected.\nIn this sense the lhs and rhs can vary independently.¬†Ok - so there are repercussions when things vary - but they are limited, as discussed above.\nFinal thought on Bridge You could simplify Bridge and have the client code talk directly to the rhs. abstract implementation interface.¬†You would be reverting to where we started on this ‚Äúroad to Bridge‚Äù.¬†Nothing wrong with that - but you would lose the ‚Äòinsulation against change‚Äô that Bridge gets you.¬†And with Bridge the lhs can have lots of complex logic and the rhs implementations need only implement the more primitive operations.¬†That is a big win.\nSolutions overview Summary of the ways of coupling your components\n  Technique  Meta-Pattern  Pattern  Description     To implementation A or B directly  Program to Interface  Interface  Interface, compile time choice  Alternative implementations of an interface. Instantiate one or the other implementation of that interface. The code that uses the object is unaware of which object it is using. \"Program to an interface\"    Interface, conditional code  Same solution as above, except choose particular implementation dynamically at runtime using a flag.    Factory  Factory Method  conditional code     registry     polymorphic factory method     Abstract Factory  abstract factory - polymorphic     conditional code     class registry     To implementation A or B via intermediary  Indirection  Dot notation drilling  methodless proxy using demeter referencing     Strategy  strategy - may be extra methods not related to the strategising     Proxy  proxy, all methods mapped (demeter is happy). inherit          Adapter  adapted proxy-like strategy.¬†different method names sometimes     Bridge  rhs - methods usually more primitive.¬†Only talk to abs. impl.  lhs - all adapted \u0026 thus changeable. can build hierarchies \n     Final thoughts The presentation of the patterns form a story of simple to complex.¬†And its a story of two broadly different techniques,¬† Getting to the implementation A or B directly Getting to the implementation A or B via an intermediary object  Adapter vs. Bridge Adapter is closer to Bridge in that the adaptation on the lhs. (the context) can be not just a renaming and mapping of methods, but extra logic and whatever it takes to make the adapation work.¬†So the lhs. is closer to the free wheeling compositional lhs of Bridge Pattern.¬†By compositional I mean that a single lhs. method can comprise of complex code and multiple calls to the rhs. methods.¬†In Bridge the lhs methods can even call on other methods in the same lhs, whereas in Adapter this is not really the intent.\nIOC (inverison of control) IOC (inverison of control) also fits in here somewhere.\nDependency injection.¬†Inject a context object or wire up dependent objects. Allows you to program normally.¬†Allows different implementations to be injected in.\nMicrokernels Microkernels also fit in here.\nAmongst other things, a Microkernel style architecture allows alternative plugins (services) to fulfil the implementation.¬† Maybe think of it as service A or B. Or plugin A or B.  There seem to be three types of MicroKernel:\n  Service location, like COM where you either ask for a service and get an interface which you use, or you call a service and the late binding binds to an appropriate service at the last minute. Style of programming: slightly different - must ask for an interface before using it.\n  Message broadcasting kernel, where messages are broadcast to all plugins and the chain of responsibility pattern is used, and a plugin/service which can make sense of the message acts on it (either consuming it or passing it on for someone else to have a go at). Style of programming: different - you must create messages send them into the kernel, either synchronously or asynchronously.\n  Dependency Injection Microkernel, where all object attributes refering to other objects (dependencies) are injected for you by a framework.¬†Rather than setting up these references yourself manually, as normal programming style dictates, you leave it to magic - which allows other implementations to be swapped in. You must of course program to interfaces not to concrete classes, in order for this trick to work.¬†Style of programming: normal, you just call methods on objects that you have references to.¬†The fact that the references have been wired up by a framework (which consults a plugin directory \u0026 setup file telling us which plugins are active) is hidden from us.\n  Maybe one or more of the above three descriptions of a Microkernel is not actually a microkernel - I am just learning about this stuff.¬†But I have seen references that suggest my analysis is correct. E.g. The Castle IOC framework for .NET calls itself a microkernel.¬†Variables as indirection A variable of type interface is really a another ‚Äòsecret‚Äô form of indirection.\nI have made a broad distinction between accessing implementations A or B either directly or via an intermediary. Thinking about it some more, when you do access A or B directly, you do so via an an intermediary variable declared of type abstract/interface.¬†This is when you are being good and ‚Äòprogramming to interfaces‚Äô.\nThus you could argue that even even when you are accessing an object (implementation A or B) directly, you are in fact still acting through an intermediary - the interface variable!\n","excerpt":"This is an exploration of how to swap implementations of objects ‚Ä¶","ref":"/blog/2005/03/05/swapping-implementations/","title":"Swapping Implementations"},{"body":"Blackboard Architectural Pattern The Blackboard Architectural Pattern is useful for problems for which no deterministic solution strategies are known. In Blackboard several specialised sub-systems assemble their knowledge to build a possibly partial or approximate solution.\nSee the paper by D. Deugo, M. Weiss and E. Kendall.\nAndy‚Äôs Presentation  Blackboard Pattern Slides by Andy\nExample Code This is a pattern that is difficult to do an example for because you would normally have to set up a large infrastructure of classes etc. I refused to be put off and presented a simple blackboard pattern implementation in python, during my talk to the Melbourne Patterns Group. Please forgive its limitations but it should at least give you an idea of what this pattern is about.\nNote that you can flick a switch in the code below and have a small GUI pop up in Swing via jython.\n\"\"\" Blackboard system by Andy Bulka Prepared for the Melbourne Patterns group - August 2004 \"\"\" import random True = 1 False = 0 print \"Welcome to my blackboard system\" class Blackboard: def __init__(self): self.experts = [] self.commonState = {} def AddExpert(self, expert): self.experts.append(expert) class Controller: def __init__(self, blackboard): self.blackboard = blackboard # init blackboard self.blackboard.commonState['answer'] = 0 self.blackboard.commonState['answerCorrectness'] = 0 def Loop(self): while self.blackboard.commonState['answerCorrectness'] \u003c 90: candidates = [] for expert in self.blackboard.experts: eagerness = expert.CanContribute() if eagerness: candidates.append((eagerness,expert)) # append a tuple candidates.sort() # move winning tuple to the end of the list winningExpert = candidates[-1][1] # -1 means the last item in list. winningExpert.execAction() return self.blackboard.commonState['answer'] def Loop_OLD(self): while self.blackboard.commonState['answerCorrectness'] \u003c 90: for expert in self.blackboard.experts: if expert.CanContribute(): expert.execAction() return self.blackboard.commonState['answer'] class AbstractExpert: def __init__(self, blackboard, outtext): self.blackboard = blackboard self.outtext = outtext def CanContribute(self): raise 'not implemented' def execAction(self): raise 'not implemented' class SmartAss(AbstractExpert): def CanContribute(self): return random.randint(1,20) def execAction(self): self.blackboard.commonState['answer'] += random.randint(1,20) print '.', self.outtext.text += '.' class WiseMan(AbstractExpert): def CanContribute(self): if self.blackboard.commonState['answer'] \u003e 200: return random.randint(1,20) else: return False def execAction(self): self.blackboard.commonState['answer'] += 1 self.blackboard.commonState['answerCorrectness'] += 5 print '*', self.outtext.text += '*' WANT_JAVA_GUI = False if WANT_JAVA_GUI: from javax.swing import JFrame, JLabel, JButton, JTextField class JHutton(JButton): pass class GUI: def __init__(self): f = JFrame() f.show() f.size = 200,200 f.title = \"Blackboard Jungle\" f.contentPane.add(JLabel(\"Expert1\")) self.txt1 = JTextField(30) f.contentPane.add(self.txt1) f.contentPane.add(JLabel(\"Expert2\")) self.txt2 = JTextField(30) f.contentPane.add(self.txt2) button = JHutton(\"Think\") f.contentPane.add(button) button.actionPerformed = self.onClick from java.awt import FlowLayout f.contentPane.layout = FlowLayout() f.pack() f.visible = 1 self.f = f blackboard = Blackboard() blackboard.AddExpert( SmartAss(blackboard, self.txt1) ) blackboard.AddExpert( WiseMan(blackboard, self.txt2) ) self.c = Controller(blackboard) def onClick(self, event): result = self.c.Loop() print print result print 'done' gui = GUI() else: # Pure text class DummyTextWidget: def __init__(self): self.text = '' import sys blackboard = Blackboard() blackboard.AddExpert( SmartAss(blackboard, DummyTextWidget())) blackboard.AddExpert( WiseMan(blackboard, DummyTextWidget())) c = Controller(blackboard) result = c.Loop() print print result print 'done' Output\nWelcome to my blackboard system . . . . . . . . . . . . . . . . . . . * . * * * * * . * . * . * . . * * * . * . . * * . . * . . * . * 371 done Example - UML Layout Another real world example of this pattern being used in is my open source¬†Python UML tool where I used this pattern to evaluate numerous attempts at laying out a UML diagram, scoring the result and then choosing the best layout.\nHere is the source code of that Python module on GitHub.\n","excerpt":"Blackboard Architectural Pattern The Blackboard Architectural Pattern ‚Ä¶","ref":"/blog/2004/08/05/blackboard-pattern/","title":"Blackboard Pattern"},{"body":"Null Object Design Pattern Sometimes I make the joke that design patterns are all about getting rid of if-else statements from your code. The null object pattern is an example of a pattern that does just that - check out the code at the bottom for details.\nWhat is it? A Null Object provides a surrogate for another object that shares the same interface, but does nothing.\n This pattern was originally written up by Bobby Wolf, in Pattern Languages of Program Design 3.\n UML Null Object Pattern\nHave I used it? Yes, I have used this pattern a few times in my work.¬†You have to be a little bit careful about managing the swapping of null obect for the real thing.¬†If bits of your code are pointing to the null object then you can‚Äôt easily swap in the real thing.¬†Better to put the null object / real object behind a proxy so that nobody knows what you are doing!\nDocumentation  Scroll down through the course pages above - or use the page next/previous buttons.\nNull Object Design Pattern chapter from Andy Bulka‚Äôs Design Patterns course book.\nExample Code Here is a Python example. The class named API is a real class with real functionality in it (note the name of this class could be anything, and not have anything to do with API‚Äôs).\nWe decide that we want to optionally log calls to our API class using a Logger class. So we modify our API class to call out to the Logger class.\nWithout Null Object from time import asctime, localtime class AbstractObject: pass # pretend python has abstract classes class RealLogging: def Log(self, msg): print 'Logged at', asctime(localtime()), msg # Proxy / wrapper around either null or real logger.  class Logger: def __init__(self): self.logger = RealLogging() def Log(self, msg): if self.logger: self.logger.Log(msg) def On(self): self.logger = RealLogging() def Off(self): self.logger = None Logger = Logger() # Usage:  class API: def doA(self): if Logger.logger: Logger.Log('Am calling A') print 'A done.' def doB(self): if Logger.logger: Logger.Log('Am calling B') print 'B done.' o = API() o.doA() o.doB() Logger.Off() o.doA() o.doB() With Null Object # Null Object Pattern  class AbstractLogging: def Log(self, msg): pass from time import asctime, localtime class RealLogging(AbstractObject): def Log(self, msg): print 'Logged at', asctime(localtime()), msg class NullLogging(AbstractObject): def Log(self, msg): return # Proxy / wrapper around either null or real logger.  class Logger: def __init__(self): self.On() def Log(self, msg): self.logger.Log(msg) def On(self): self.logger = RealLogging() def Off(self): self.logger = NullLogging() Logger = Logger() # Usage:  class API: def doA(self): Logger.Log('Am calling A') print 'A done.' def doB(self): Logger.Log('Am calling B') print 'B done.' o = API() o.doA() o.doB() Logger.Off() o.doA() o.doB() Output Without logging:\nA done. B done. With logging:\nLogged at Fri Jan 23 17:28:01 2009 Am calling A A done. Logged at Fri Jan 23 17:28:01 2009 Am calling B B done. Notice that in the null object implementation, there are no ‚Äúif statements‚Äù in the client code (API class), which means we turn on logging by injecting in a different instance of Logger rather than checking a flag. Arguably this is more flexible and cleaner. You even have more options to swap (or inject) different kind of Logger classes with this pattern.\nThe Null Object pattern is about switching in a Logger class that does nothing.\n","excerpt":"Null Object Design Pattern Sometimes I make the joke that design ‚Ä¶","ref":"/blog/2002/10/04/null-object-pattern/","title":"Null Object Pattern"},{"body":"What is it like to use design pattern in real life programming?\nDo the sometimes academic patterns translate into the real world?\nThe answer is yes. I will back this up with three examples of where I have used patterns in real world projects.\n Scroll down through the slides above\n-Andy Bulka\n","excerpt":"What is it like to use design pattern in real life programming?\nDo the ‚Ä¶","ref":"/blog/2002/09/04/using-design-patterns-in-real-projects/","title":"Using Design Patterns in Real Projects"},{"body":"Introduction As design patterns become more mainstream, various IDE‚Äôs (Integrated Development Environments) and UML modelling software environments have begun to introduce support for design patterns. For example, developers browse through a catalog of design patterns and drop one onto a UML workspace, whereupon various classes appear with the appropriate methods and attributes inserted. Usually there is an interface whereby roles in the design pattern can be mapped onto existing classes, or alternatively, new classes are created for you. This paper explores the state of pattern automation software, discusses the pros and cons of various approaches and then goes on to discusses the broader issues raised by the attempt to automate something which some argue, in principle, perhaps should not be automated at all..\nNote: The pattern automation paper was followed up a few years later with a talk entitled design pattern automation - part 2 SEE BELOW which reviews the current crop of UML tools circa 2006. Fot a review of Netbeans 6 design pattern support - stay tuned for a blog posting after I give my talk to the Melbourne Patterns Group in Feb 2009.\nThis paper is a revision of one that appeared at KoalaPLoP 2002 ‚Äì the ThirdAsia-Pacific Conference on Pattern Languages of Programmes. Conferences in Research and Practice in Information Technology,Vol. 13. J. Noble, Ed. Reproduction for academic, not-for profit purposes permitted provided this text is included.\nDesign Pattern Automation \u0026 UML Tool Support Various UML Tools support design pattern usage.¬†You typically drag and drop patterns onto your workspace and they appear as UML classes.¬†Its a bit more complicated than this, and raises all sorts of interesting issues.¬†Read the pdf (part 1) and then read the powerpoint and watch the video (part 2).\nPart 1 - Early tools and the philosophy of pattern automation  Part 2 - Design Pattern Tools as of 2006 Here are the slides from a talk entitled ‚ÄúDesign Pattern support in UML tools - part II‚Äù which I gave in October 2006 to the Melbourne Patterns Group, Australia.\n Alternatively, view the above powerpoint on slideshare¬†or download the powerpoint .ppt directly:\nAddendum As part of my Design Pattern Automation - Part 2 talk, I recorded some of that session.¬†Here is a youtube¬†video of how to apply design patterns using IBM‚Äôs Rational tool.¬†Apologies about the sound quality - just look at the pictures!\nDemonstration of Patterns in IBM‚Äôs Rational tool. http://www.youtube.com/watch?v=IjKClDX2dUU\n","excerpt":"Introduction As design patterns become more mainstream, various IDE‚Äôs ‚Ä¶","ref":"/projects/patterns/design-pattern-automation/","title":"Design Pattern Automation"},{"body":"How can IDE visualisation features be further enhaced by UML and Design Patterns to assist developers. It discusses using the revolutionary UML tool ModelMaker (now discontinued) in conjuntion with Delphi.\nModelMaker allowed you to apply patterns onto your code using a UI\n This is a talk I gave at the time that I was into Delphi programming.¬†Presented to the Australian Delphi User Group in December 1999.\n Engineers use models  Engineers produce plans before building bridges Electrical engineers have a language of electrical symbols Architects have blueprints  What do software engineers / programmer for a modelling tool?\nDo programmers necessarily need a strict visual language like other engineers?\nAnswer: Most programmers use visual IDE (integrated development environments) to visualize and organize their work.¬†For most programmers, this ‚Äòinformal‚Äô modelling is sufficient for their needs.\nDatabase tables have a natural visual reprentation of a grid/table e.g.\nthough when you want to visualise the often complex relationships between multiple tables, you may want to use something like the Delphi 5 Data Diagram:\nWe also have visual modelling in the form of hierarchical representation of classes (or elements of a data module, in Delphi 5).¬†This form of representation is extrememly useful, however, these hierarchical views do not show how objects are connected to each other.\nWhere does UML come in? A modern IDE (Integrated Development Environments) like Delphi encourage a logical two-tier design where the data sits in the database and both the display \u0026 business logic sits in the presentation classes/components.¬†Really, most programmers are filling in the blanks (e.g. event code) and setting properties - the application code hangs off the IDE / Delphi / VCL / component framework.\nWhen someone asks you ‚Äúwhere is your application code?‚Äù you typically answer in my GUI.\nIf your application gets\n large or starts to create other extra classes  then you have no means of visualising your application code/classes.¬†Not only are they embedded behind GUI components, but they are effectively invisible to broad visualisation and organisation.\nModelling to the rescue Modelling software allows you to visualise your application code/classes, using UML as the visual symbol language.¬†E.g. Objects and pointers to other objects are represented by boxes and lines..\nWhen using a UML modeller, in addition to being able to visualize your extra application classes, you can also\n  Visualize your existing Delphi components (including forms)\n  Take a punt and model your data as real objects instead of DB tables - that way you can give them behaviour.¬†They become real OO objects that model the real world domain your application is about.¬†Your application would then be based on a proper object model.\n  Keep application / business logic out of the GUI, and in a separate tier - called the model.¬†An OO model not only can model the real world domain your application is about, but can also be the engine powerhouse of your app.\n  Visualising a form in UML A UML model can also model \u0026 incorporate GUI forms.¬†A simple Delphi application with a form and a button on that form can be represented in the following ways:\nThus this form containing a button\nwhich is equivalent to the following Delphi code\ntype TForm1 = class (TForm) Hello: TButton; procedure HelloClick(Sender: TObject); end; can be represented by the following UML diagram\nNote that a form aggregates or contains a button, and this is represented by a arrow pointer.¬†If the button‚Äôs lifetime is tied to the lifetime of the form, then the arrow should have a black diamond instead of a clear one (if you are a stickler for correct UML).\nModelmaker ModelMaker‚Äôs UI integrated code, UML and design patterns\nModelMaker benefits ModelMaker (now unfortunately discontinued) represented a brand new way to develop classes and component packages for Borland Delphi (1/2/3/4/5). ModelMaker is a two-way class tree oriented productivity and UML-style CASE tool specifically designed for generating native Delphi code (in fact it was made using Delphi and ModelMaker). Delphi‚Äôs Object Pascal language is fully supported by ModelMaker. From the start ModelMaker was designed to be a smart and highly productive tool. It has been used to create classes for both real-time / technical and database type applications. Versions 4 and 5 have full reverse enginering capabilities.\nModelMaker supports drawing UML style class diagrams and from that perspective it looks much like a traditional CASE tool. The key to ModelMaker‚Äôs magic, speed and power however is the active modelling engine which stores and maintains all relationships between classes and their members. Renaming a class or changing its ancestor will immediately propagate to the automatically generated source code. Tasks like overriding methods, adding events, properties and access methods are reduced to selecting and clicking.\nThe main difference between ModelMaker and other CASE tools is that design is strictly related to and natively expressed in Delphi code. This way there is a seamless transition from design to implementation currently not found in any other CASE tool. This approach makes sure your designs remain down to earth. The main difference between ModelMaker and other Delphi code generators are it‚Äôs high level overview and restructuring capabilities letting you deal with complex designs.\nIn ModelMaker you‚Äôll find a synergy of ideas from the cutting edge of object-oriented and component-based technology. It was inspired by the work of methodologists like Ivar Jacobson (OOSE), Ralph Johnson (design patterns) and Karl Lieberherr (adaptive software).\nA unique feature, currently not found in any development environment for Delphi, is the support for design patterns. A number of patterns are implemented as ‚Äòready to use‚Äô active agents. A ModelMaker Pattern will not only insert Delphi style code fragments to implement a specific pattern, but it also stays ‚Äòalive‚Äô to update this code to reflect any changes made to the design.\nAs a result, ModelMaker lets you:\n Speed up development Think more about designing instead of typing code. Design without compromising and refine and experiment with designs until they feel just right. Create and maintain magnitudes larger models in magnitudes less time. Document you designs in UML style diagrams.  Modelmaker Tutorial  Creating classes Adding methods and properties/fields to classes Creating constructors and Destructors - MM adds the ‚Äòcall inherited‚Äô code Units and code generation, two way synch.  A sample of Andy‚Äôs Modelmaker live demo tutorials.\nCreating a Simple Pointer property How to create 2 new classes and have one point to the other.¬†Also notice how a Delphi property is automatically created to represent the pointer.¬†Of course you can add the property by clicking on the ‚ÄúAdd property‚Äù toolbar button, but as demonstrated, it is sure sometimes conventient to be able to drag and draw a pointer - additionally, it makes it clear that the property represents a relationship between two classes, rather than the property merely holding a value or some sort.\nApplying the Wrapper design pattern Notice we create a third class and add 4 methods to it.¬†We want to then access these methods indirectly, via the TDefault1 class.¬†So we duplicate the methods in the TDefault1 class, delegating / redirecting these calls to the appropriate class, where the real methods live.¬†This technique is known as ‚Äòwrapper pattern‚Äô. Note that the pattern will keep the method names up to date e.g. if you rename the wrapped class TDefault3 method ‚ÄòMember1‚Äô into ‚ÄòMember1A‚Äô then ModelMaker will automatically also rename TDefault1 class‚Äôs method ‚ÄòMember1‚Äô into ‚ÄòMember1A‚Äô.\nOther uses of this pattern include simulating multiple inheritance (e.g. by having a class delegate out functionality to another class, you create the illusion of complex functionality coming from multiple classes).\nInitialising (Create) and owning (Destroy) objects Another use of the wrapper pattern is creating composite objects out of smaller parts. The client needs only to deal with one class, but behind the scenes there may be many classes involved.¬†Related to ‚ÄòFacade pattern‚Äô.¬†There are issues of initialisation: Do you want the big class to create the sub classes?¬†If so, make a Create constructor method in the big class TDefault1 and do the creation of the subclasses (TDefault2, TDefault3) there.¬†Modelmaker‚Äôs creational wizard can help build the code in the constructor automatically - and the destruction code as well. E.g.\nIn the above demo we are creating Create and Destroy methods for the TDefault1 class, so that it both creates and destroys its ‚Äòsub-classes‚Äô when it itself is created/destroyed.¬†After running the ModelMaker creational wizard on the TDefault1 class, the resulting Create method is\ninherited Create; FDefault2 := TDefault2.Create; FDefault3 := TDefault3.Create; and the resulting Destroy method is\nFDefault2.Free; FDefault3.Free; inherited Destroy; Note: the ‚Äòcreational wizard‚Äô only generates code if it finds a create or destroy method.¬†Also, the creational wizard only generates code for FIELDS that have been marked ‚Äòinitialised‚Äô (this will generate the create code) or ‚Äòowned‚Äô (this will create the free code).\nInterfaces, Patterns, Templates After a long period of design \u0026 development, a class can end up containing many, many methods and properties. Often these methods and properties can be grouped. Wouldn‚Äôt it be great if we could name and distinguish these groups?¬†Well we already do!\nClasses are an attempt to group functionality.¬†Class A supports methods 1 \u0026 2, Class B inherits from B and also supports methods 3 \u0026 4.\nInterfaces are another attempt to group functionality.¬†A class can support/implement multiple interfaces.\nPatterns are sets of methods and properties in a class, relating to methods and properties in one or more other classes.\nModelmaker templates are groups of methods \u0026 properties that you can save to disk and re-apply to any class.¬†Parametrisation means you can customise the code as you apply it.¬†You only get one shot at this.¬†After the code template is applied, you end up with raw code in your class, which you need to maintain manually.¬†This compares to ModelMaker‚Äôs design patterns, which are more ‚Äòalive‚Äô e.g. references to a renamed method get maintained correctly within a ModelMaker pattern (e.g. Modelmaker‚Äôs visitor pattern)\nWhilst ModelMaker is discontinued, you can read the manual and still download a trial of the old software.\nThe Future As seen from 2000‚Äôs - nothing like this ever happened\nWorking at the level of UML, ‚Äòsets/groupings of methods‚Äô and patterns, is a significantly higher level than Delphi code - which is starting to look like assembly language.¬†One day we will be applying colored ‚ÄòLEGO‚Äô blocks that represent various groups of methods \u0026 properties - joining them together, much like the other component / bean technology we have today.\nHere is an example of a Composite \u0026 Proxy pattern combined, from the book Pattern Hatching: Design Patterns Applied by Vlissides:\nMore ideas for what a programming environment of the future might look like: Adding a refactoring tool to ModelMaker + more patterns + templates.¬†Sequence Diagrams auto-generated from code.¬†Color coded groupings of patterns and methods/properties.\nHere is an example of a ‚Äòrefactoring‚Äô from Martin Fowler‚Äôs book Refactoring: Improving the Design of Existing Code:\nModelmaker can make easy work of accomplishing this refactoring using drag and drop of methods, however a built in, dedicated refactoring tool (as in Smalltalk and Java) would make the task even clearer and easier.\n2020 Postscript: Modern refactoring tools are now commonplace.\n-Andy Bulka\n","excerpt":"How can IDE visualisation features be further enhaced by UML and ‚Ä¶","ref":"/blog/2000/01/04/patterns-modelmaker-beyond/","title":"Patterns, ModelMaker \u0026 Beyond"},{"body":"  #td-cover-block-0 { background-image: url(/about/featured-background-cabin_hu711514a202e4ee80bf848c5946e20294_385912_960x540_fill_q75_catmullrom_bottom.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/about/featured-background-cabin_hu711514a202e4ee80bf848c5946e20294_385912_1920x1080_fill_q75_catmullrom_bottom.jpg); } }  About Andy Bulka A sample site using the Docsy Hugo theme.        Goldydocs is a sample site using the Docsy Hugo theme that shows what it can do and provides you with a template site structure. It‚Äôs designed for you to clone and edit as much as you like. See the different sections of the documentation and site for more ideas.     This is another section      This is another section     ","excerpt":"  #td-cover-block-0 { background-image: ‚Ä¶","ref":"/about/","title":"About Goldydocs"},{"body":"This is the blog section. It has two categories: News and Releases.\nTalks given but unfortunately no website presentation materials\n 2007 July - Object Role Modeling - What is it? 2006 October - More on UML Pattern Tools 2004 October - Design Patterns found in the C# Language 2004 June - Object Thinking - Book Review 2003 Aug - Pattern Automation and UML 2003 January - Object Orientation, UML and Delphi 2002 December - Mediator Dialog Patterns 2002 October - An Introduction to Refactoring  Files in these directories will be listed in reverse chronological order.\n","excerpt":"This is the blog section. It has two categories: News and Releases. ‚Ä¶","ref":"/blog/","title":"Docsy Blog"},{"body":"  #td-cover-block-0 { background-image: url(/featured-background-staircase_hu711514a202e4ee80bf848c5946e20294_458706_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured-background-staircase_hu711514a202e4ee80bf848c5946e20294_458706_1920x1080_fill_q75_catmullrom_top.jpg); } }  Andy Bulka's Software Blog \u0026 Projects Learn More   Download   Andy Bulka is a software developer in Melbourne, Australia\n\n        Hi, my name is Andy Bulka and I am a Python and Nodejs/Electron software developer.¬†I‚Äôve also recently discovered Flutter, which is likely going to dominate a large part of software development in the future.\nThis website holds my blog on software development incl. UML and pattern based software development.¬†These blog entries are often based on presentations that I have given to live audiences at various programmer enthusiast user groups or conferences.\n      New chair metrics! The Goldydocs UI now shows chair size metrics by default.\nPlease follow this space for updates!\n   Contributions welcome! We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more ‚Ä¶\n   Follow us on Twitter! For announcement of latest features etc.\nRead more ‚Ä¶\n     This is the second Section        Download from AppStore Get the Goldydocs app!\n   Contributions welcome! We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more ‚Ä¶\n   Follow us on Twitter! For announcement of latest features etc.\nRead more ‚Ä¶\n     The Patterns Movement  Capturing hard-won software design experience in the form of design patterns and architectural patterns is a noble cause that everyone can contribute to.¬†You can contribute by writing patterns and maybe even coming to a [Plop patterns conference](http://hillside.net/patterns/). Basically when you see a software development technique a few times, and see that it isn't yet documented - write it up in Pattern format and give it a name!¬†A pattern is more than just a \"tip\" or technique though - a pattern represents an abstract idea - that can be implemented in various ways depending on your circumstances.\n The Patterns Movement is spearheaded by Hillside and the Plop conferences, held each year.  There are a couple of things I would like to see happen in the patterns world.    First, it would be nice if there was a single, authoritative repository of patterns. Yes an attempt has been made - a catalog book and and various websites - but nothing authoratative.¬†I'm starting a list of links [here](/index.php/blog/central_repository/ \"Towards a central repository of Design Patterns\").   Secondly, it would be nice to have deep design pattern support in UML within all our favourite IDE's.¬†For example Netbeans has it all - coding, form design, UML and design pattern support - albiet not as integrated as it could be and not as polished as it could be. **Update:** Unfortunately Netbeans seems to have dropped UML support in recent builds.   If IDE‚Äôs are not your cup of tea, then how about this: source code should have comment markers indicating where the patterns are, so that a reverse engineering tool can visualise not only the UML but also where the patterns are. My own UML tool PyNSource will have such a feature - est. June 2011 (turns out this never happened :-).\nFurther advancements are arguably executable UML and even the possibility of building software without code.¬†I muse a bit about this in my blog entry on software visualisation and my paper on design pattern tools.¬†First, it would be nice if there was a single, authoritative repository of patterns. Yes an attempt has been made - a catalog book and and various websites - but nothing authoratative.¬†I‚Äôm starting a list of links here.\nPatterns at all levels need to be core visual building blocks of IDE‚Äôs, or at the very least, extractable from source code into some visual UML tool - rather than being design ghosts that float around, implicit, in our source code.\n This site is a 2020 rebuild in progress - For full site, see http://www.andypatterns.com/\n    ","excerpt":"  #td-cover-block-0 { background-image: ‚Ä¶","ref":"/","title":"Goldydocs"},{"body":"Various projects. Still to be sorted into categories. See the Misc area for links back to the current andypatterns.com site.\n","excerpt":"Various projects. Still to be sorted into categories. See the Misc ‚Ä¶","ref":"/projects/","title":"Projects"},{"body":"","excerpt":"","ref":"/search/","title":"Search Results"}]
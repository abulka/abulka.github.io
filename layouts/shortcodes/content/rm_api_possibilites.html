<table cellspacing="1" cellpadding="9">
    <tbody>
        <tr>
            <th></th>
            <th>Relationship Scenario</th>
            <th>Example Python Implementation</th>
        </tr>


        <!-- 

        one to one

        -->

        <tr>
            <td colspan="3">
                <h3>Implementing <b>one</b> to <b>one</b> relationships between class X and Y</h3>
            </td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>#1.</td>
            <td>
                <p><i>1 → 1, directional, all methods on X</i></p>
                <pre>
  Singular API             No API
 ______________        ______________
|       X      |      |       Y      |
|______________|      |______________|
|              |      |              |
|void  setY(y) |1    1|              |
|Y     getY()  |⎯⎯⎯⎯⎯⎯⎯⎯⎯→|              |
|void  clearY()|      |              |
|______________|      |______________|
				</pre>
            </td>
            <td>
                <pre>
class X:
  def __init__(self): 
    rm.enforce("xtoy", "onetoone", "directional")
	
  def setY(self, y): 
    rm.add_rel(self, y, "xtoy")
	
  def getY(self): 
    rm.find_target(source=self, rel_id="xtoy")
	
  def clearY(self): 
    rm.remove_rel(self, self.getY(), "xtoy")
				</pre>
                <pre>
class Y:
  pass
				</pre>
            </td>
        </tr>




        <tr>
            <td>#2.</td>
            <td>
                <p><i>1 → 1, directional, all methods on Y</i></p>
                <pre>
    No API              Singular API
 ______________        ______________
|       X      |      |       Y      |
|______________|      |______________|
|              |      |              |
|              |1    1| setX(x)      |
|              |⎯⎯⎯⎯⎯⎯⎯⎯→ | getX()       |
|              |      | clearX()     |
|______________|      |______________|
				</pre>
            </td>
            <td>
                <pre>
class X:
  pass
				</pre>
                <pre>
class Y:
  def __init__(self): 
    rm.enforce("xtoy", "onetoone", "directional")

  def setX(self, x):
    rm.add_rel(x, self, "xtoy")

  def getX(self):
    rm.find_source(target=self, rel_id="xtoy")

  def clearX(self):
    rm.remove_rel(self.getX(), self, "xtoy")
				</pre>
            </td>
        </tr>




        <tr>
            <td>#3.</td>
            <td>
                <p><i>1 ←→ 1, bi-directional, methods on both X and Y</i></p>

                <pre>
   Singular API         Singular API
 ______________        ______________
|       X      |      |       Y      |
|______________|      |______________|
|              |      |              |
|void  setY(y) |1    1| setX(x)      |
|Y     getY()  | ←⎯⎯⎯⎯→ | getX()       |
|void  clearY()|      | clearX()     |
|______________|      |______________|
				</pre>
            </td>
            <td>
                <pre>
class X:                    
  def __init__(self):
    rm.enforce("xy", "onetoone", "bidirectional")
  
  def setY(self, y):
    rm.add_rel(self, y, "xy")
  
  def getY(self):
    rm.find_target(self, "xy")
  
  def clearY(self):
    rm.remove_rel(self, self.getY(), "xy")
				</pre>
                <pre>
class Y:
  def __init__(self):
    rm.enforce("xy", "onetoone", "bidirectional")

  def setX(self, x):
    rm.add_rel(self, x, "xy")

  def getX(self):
    rm.find_target(self, "xy")

  def clearX(self):
    rm.remove_rel(self, self.getX(), "xy")
				</pre>
            </td>
        </tr>




        <tr>
            <td>#3A.</td>
            <td>
                <p><i>1 → 1, directional, all methods on X, back pointer</i></p>
                <pre>
            Singular API
        ___________________
       |       X           |&lt;-------,
       |___________________| 1      |
     1 |                   |        |
  |---→| void  _setX(x)    |        |
  |    | X     _getX(x)    |        |
  |____| X     _getBack()  |........|
back   |___________________|    x
				</pre>
                <p>This is the
                    <a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite Design Pattern</a> - good for representing trees etc.
                </p>
                <p>
                    <span style="font-size: small;">See backpointer discussion
                        <a href="#backpointers">below</a> which includes a fully
                        worked out example of case 3A, in Python.
                    </span>
                </p>

            </td>
            <td>
                <pre>
class X:
  def __init__(self):
    rm.enforce("xtox", "onetoone", "directional")

  def _setX(self, x):
    rm.add_rel(self, thing, "xtox")

  def _getX(self):
    rm.find_target(source=self, rel_id="xtox")

  def _getBack(self):
    rm.find_source(target=self, rel_id="xtox")

				</pre>
                <pre>
x = property(_getThing, _setThing)

back = property(_getBack)
				</pre>
            </td>
        </tr>


        <!-- 

        one to many


        -->


        <tr>
            <td colspan="3">
                <h3>Implementing <b>one</b> to <b>many</b> relationships between class X and Y</h3>
            </td>
            <td></td>
            <td></td>
        </tr>


        <tr>
            <td>#4.</td>
            <td>
                <p><i>1 → *, directional, all methods on X</i></p>


                <pre>
  Plural  API             No API
 _____________        ______________
|      X      |      |       Y      |
|_____________|      |______________|
|             |      |              |
|addY(y)      |1    *|              |
|getAllY()    | ⎯⎯⎯⎯⎯⎯→ |              |
|removeY(y)   |      |              |
|_____________|      |______________|
				</pre>
            </td>
            <td>
                <pre>
class X:
  def __init__(self):
    rm.enforce

  def addY(self, y):
    rm.add_rel(self, y, "xtoy")

  def getAllY(self):
    rm.find_targets(self, "xtoy")

  def removeY(self, y):
    rm.remove_rel(self, y, "xtoy")
				</pre>
                <pre>
class Y:  # no methods on rhs
  pass
				</pre>
            </td>
        </tr>




        <tr>
            <td>#5.</td>
            <td>
                <p><i>1 ←→ *, bi-directional, methods on both X and Y</i></p>

                <pre>
  Plural  API          Singular API
 _____________        ______________
|      X      |      |       Y      |
|_____________|      |______________|
|             |      |              |
|addY(y)      |1    *| setX(x)      |
|getAllY()    | ←⎯⎯⎯⎯→ | getX()       |
|removeY(y)   |      | clearX()     |
|_____________|      |______________|
        </pre>
                <ul>
                    <li>X has the required plural API</li>
                    <li>Y has the reciprocal singular API</li>
                </ul>
                <p>
                    Since there are two API's, one on each class, this makes it a bidirectional relationship.
                </p>
                <p>
                    However - there still remains a sense of
                    <i>directionality</i> because the one to many is directional
                    <i>i.e.</i> the the lhs. 'one' side is the X and the rhs. 'many' side is the Y, not the other way around.
                </p>
            </td>
            <td>
                <pre>
class X:
  def __init__(self):
    rm.enforce("xtoy", "onetomany", "bidirectional")

  def addY(self, y):
    rm.add_rel(self, y, "xtoy")

  def getAllY(self):
    rm.find_targets(self, "xtoy")

  def removeY(self, y):
    rm.remove_rel(self, y, "xtoy")
				</pre>
                <pre>
class Y:
  # though bi, there is still a direction!
  def setX(self, x):
    rm.add_rel(x, self, "xtoy")

  def getX(self):
    rm.find_target(self, "xtoy")

  def clearX(self):
    rm.remove_rel(self, self.getX(), "xtoy")
				</pre>
            </td>
        </tr>






        <tr>
            <td>#5A.</td>
            <td>
                <p><i>1 ←→ *, bi-directional, methods on both X and Y</i></p>
                <p>Alternative implementation of scenario 5, using "directional" and a backpointer method</p>

            </td>
            <td>
                <pre>
class X:
  def __init__(self):
    rm.enforce("xtoy", "onetomany", "directional")  # DIFFERENT to 5, 'directional' not 'bidirectional'

  def addY(self, y):
    rm.add_rel(self, y, "xtoy")  # same as 5.

  def getAllY(self):
    rm.find_targets(self, "xtoy")  # same as 5.

  def removeY(self, y):
    rm.remove_rel(self, y, "xtoy")  # same as 5.
      </pre>
                <pre>
class Y:
  def setX(self, x):
    rm.add_rel(x, self, "xtoy")  # same as 5.

  def getX(self):
    rm.find_source(self, "xtoy")  # DIFFERENT to 5, uses 'find_source' not 'find_target'

  def clearX(self):
    rm.remove_rel(self.getX(), self, "xtoy")  # DIFFERENT to 5, source and target params swapped
      </pre>
            </td>
        </tr>




        <!-- 

        many to one
            
        -->


        <tr>
            <td colspan="3">
                <h3>Implementing <b>many</b> to <b>one</b> relationships between class X and Y</h3>
            </td>
            <td></td>
            <td></td>
        </tr>


        <tr>
            <td>#6.</td>
            <td>
                <p><i>* → 1, directional, all methods on Y</i></p>
                <pre>
    No API              Plural  API
 ______________        ______________
|     X        |      |       Y      |
|______________|      |______________|
|              |      |              |
|              |*    1|addX(x)       |
|              | ⎯⎯⎯⎯⎯⎯→ |getAllX()     |
|              |      |removeX(x)    |
|______________|      |______________|
				</pre>
            </td>
            <td>
                <p>DRAFT API (not tested)</p>
                <pre>
class X:
  pass
				</pre>
                <pre>
class Y:
  def addX(x) -> None:
    rm.add_rel(x, this, "xtoy")

  def getAllX() -> List:
    return rm.find_sources(this, "xtoy")

  def removeX(x) -> None:
    rm.remove_rel(x, this, "xtoy")
				</pre>
                <p></p>
            </td>
        </tr>




        <tr>
            <td>#7.</td>
            <td>
                <p><i>* ←→ 1, bi-directional, methods on both X and Y</i></p>




                <pre>
  Singular API          Plural  API
 ______________        ______________
|     X        |      |       Y      |
|______________|      |______________|
|              |      |              |
|void  setY(y) |*    1|addX(x)       |
|Y     getY()  | ←⎯⎯⎯⎯→ |getAllX()     |
|void  clearY()|      |removeX(x)    |
|______________|      |______________|
				</pre>
            </td>
            <td>
                <p>DRAFT API (not tested)</p>
                <pre>
class X:
  def setY(y) -> None:
    rm.add_rel(this, y, "xtoy")

  def getY() -> Y:
    rm.find_target(this, "xtoy")

  def clearY() -> None:
    rm.remove_rel(this, getY(), "xtoy")
				</pre>
                <pre>
class Y:
  def addX(x) -> None:
    rm.add_rel(x, this, "xtoy")

  def getAllX() -> List:
    rm.find_sources(this, "xtoy")

  def removeX(x) -> None:
    rm.remove_rel(x, this, "xtoy")
				</pre>
                <p></p>
            </td>
        </tr>




        <!-- 

        many to many
            
        -->


        <tr>
            <td colspan="3">
                <h3>Implementing <b>many</b> to <b>many</b> relationships between class X and Y</h3>
            </td>
            <td></td>
            <td></td>
        </tr>


        <tr>
            <td>#8.</td>
            <td>
                <p><i>* → *, directional, all methods on X</i></p>
                <pre>
  Plural  API              No API
 _____________        ______________
|      X      |      |       Y      |
|_____________|      |______________|
|             |      |              |
|addY(y)      |*    *|              |
|getAllY()    | ⎯⎯⎯⎯⎯⎯→ |              |
|removeY(y)   |      |              |
|_____________|      |______________|
				</pre>
            </td>
            <td>
                <p>DRAFT API (TODO, not tested)</p>
            </td>
        </tr>




        <tr>
            <td>#9.</td>
            <td>
                <p><i>* → *, directional, all methods on Y</i></p>

                <pre>
      No API            Plural  API
 ______________        ______________
|     X        |      |       Y      |
|______________|      |______________|
|              |      |              |
|              |*    *|addX(x)       |
|              | ⎯⎯⎯⎯⎯⎯→ |getAllX()     |
|              |      |removeX(x)    |
|______________|      |______________|
				</pre>
            </td>
            <td>
                <p>DRAFT API (TODO, not tested)</p>
            </td>
        </tr>





        <tr>
            <td>#10.</td>
            <td>
                <p><i>* ←→ *, bi-directional, methods on both X and Y</i></p>

                <pre>
   Plural  API          Plural  API
 ______________        ______________
|     X        |      |       Y      |
|______________|      |______________|
|              |      |              |
| addY(y)      |*    *| addX(x)      |
| getAllY()    | ←⎯⎯⎯⎯→ | getAllX()    |
| removeY(y)   |      | removeX(x)   |
|______________|      |______________|
				</pre>
            </td>
            <td>
                <p>DRAFT API (TODO, not tested)</p>
            </td>
        </tr>
    </tbody>
</table>
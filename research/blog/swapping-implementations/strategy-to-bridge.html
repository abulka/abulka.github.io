<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Untitled</title>
    <meta name="author" content="Andy Bulka">

    <!-- <link rel="stylesheet" href="css/styles.css?v=1.0"> -->

</head>

<body>
    <!-- <script src="js/scripts.js"></script> -->
    <h1>From Strategy to Bridge</h1>
    <p>This is a story of how we get from patterns like the Interface pattern to Factory, Strategy, Proxy, Adapter, and
        finally to the full blown Bridge Design Pattern.  </p>
    <p>This is an exploration of how to swap implementations of objects within our software architectures.</p>
    <p>This article was formerly known as The "Road to the Bridge".</p>
    <h2>
        <!--mstheme--><span style="color: #663399;">The problem
            <!--mstheme--></span></h2>
    <p>We want to be flexible in our architecture.  We want to be able to swap implementations of objects/classes
        easily.  </p>
    <table style="width: 100%;" border="0" cellspacing="0" cellpadding="0">
        <!--msthemelist-->
        <tbody>
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Build to anticipate and celebrate
                        change.
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Program to interfaces, not
                        implementations..
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
        </tbody>
    </table>
    <!--mstheme-->
    <h2>
        <!--mstheme--><span style="color: #663399;"><img
                src="http://www.atug.com/andypatterns/images/PathToBridge_AorB.gif" alt="" width="186" height="165"
                border="0" />
            <!--mstheme--></span></h2>
    <h2>
        <!--mstheme--><span style="color: #663399;">The road we journey on...
            <!--mstheme--></span></h2>
    <p>Let's examine the range of solutions -  showing the story of how to bind to two different implementations of the
        same interface - simple ways and more complex ways. Specifically how we move from:<br /> <br /> 1. compile-time
        binding (one or the other is chosen by compiled code) to<br /> 2. factory based binding (one or the other is
        returned by a factory) to<br /> 3. dynamic binding using an intermediary object,<br /> <br /> where #3 is
        achieved using Strategy, Adapter and Proxy, then this ultimately leads us to Bridge.</p>
    <p>This journey strikes me as a powerful way of looking at a deep and common problem (building to embrace change),
        and that also unites multiple patterns under the one theme. Given programmers love the ideal of 'programming to
        interfaces' and being able to swap in different implementations, this story will show how to do it at many
        different levels and in fact how many of the design patterns are all about helping us achieve it.</p>
    <p align="center"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvrule.gif" alt="" width="600"
            height="10" /></p>
    <h1>
        <!--mstheme--><span style="color: #663399;"><a name="Interface pattern"></a>Interface pattern
            <!--mstheme--></span></h1>
    <h2>
        <!--mstheme--><span style="color: #663399;">Interface, compile time choice
            <!--mstheme--></span></h2>
    <p>Alternative implementations of an interface. Instantiate one or the other implementation of that interface. The
        code that uses the object is unaware of which object it is using. "Program to an interface"</p>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_Interface01.gif" alt="" width="292" height="170"
            border="0" /></p>
    <pre>Worker o = new A()<br />// Worker o = new B()</pre>
    <!--mstheme-->
    <p> </p>
    <pre>o.DoSomething()</pre>
    <!--mstheme-->
    <p>Here the choice is at compile time, by commenting out one or the other instantiation.</p>
    <h2>
        <!--mstheme--><span style="color: #663399;">Interface, dynamic run time choice
            <!--mstheme--></span></h2>
    <p>Same solution except choose particular implementation dynamically at runtime using a flag.</p>
    <pre>if flag<br />   Worker o = new A()<br />else<br />   Worker o = new B()</pre>
    <!--mstheme-->
    <p> </p>
    <pre>o.DoSomething()    // we don't know if its an A or a B.  Everything works ok.</pre>
    <!--mstheme-->
    <p align="center"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvrule.gif" alt="" width="600"
            height="10" /></p>
    <h2>
        <!--mstheme--><span style="color: #663399;">Factory
            <!--mstheme--></span></h2>
    <p>Create A or B at runtime by asking another class to create the concrete object for us.  Pass in the flag to the
        factory or let the factory decide for itself which implementation we want.</p>
    <p>Factory class is the only class to refer to concrete products. The client refers to the interface/abstract class
        only.</p>
    <p>We are still talking directly to the concrete object (either an A or a B).</p>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_Factory.gif" alt="" width="885" height="330"
            border="0" /></p>
    <p>There are a number of factory method variants:</p>
    <h3>
        <!--mstheme--><span style="color: #663399;"><a name="Simple Super Dumb Factory"></a>Simple Super Dumb Factory
            <!--mstheme--></span></h3>
    <p>Encapsulates the "dynamic run time choice" solution discussed in the beginning of this talk. Benefit is that the 
        conditional logic containing the if statement is hidden and possibly centralized in a factory class.</p>
    <p>Factory class is the only class that refers directly to concrete products. Client refers only to
        interface/abstract class.</p>
    <p>The choice is made via conditional code.</p>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_FactorySimple.gif" alt="" width="890" height="327"
            border="0" /></p>
    <pre>Factory f = new SimpleFactory()<br />Worker o = f.CreateWorker()</pre>
    <!--mstheme-->
    <p> </p>
    <pre>o.DoSomething()    // we don't know if its an A or a B.  Everything works ok.</pre>
    <!--mstheme-->
    <h3>
        <!--mstheme--><span style="color: #663399;"><a name="Registry Based Factory"></a>Registry Based Factory
            <!--mstheme--></span></h3>
    <p>Maintains a registry of mappings between strings (or any type of key e.g. objects, class references, numbers
        etc.) and class references.  Benefit: more generalized, no if statements. </p>
    <p>Factory class is the only class that refers directly to concrete products. Client refers only to
        interface/abstract class.</p>
    <p>The choice is made via registry key.</p>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_FactoryRegistry.gif" alt="" width="877"
            height="428" border="0" /></p>
    <pre>key = 'worker a'   // in setup code somewhere</pre>
    <!--mstheme-->
    <p> </p>
    <pre>Factory f = new RegistryFactory()<br />Worker o = f.CreateWorker(key)</pre>
    <!--mstheme-->
    <p> </p>
    <pre>o.DoSomething()    // we don't know if its an A or a B.  Everything works ok.</pre>
    <!--mstheme-->
    <h3>
        <!--mstheme--><span style="color: #663399;">GOF Factory Method
            <!--mstheme--></span></h3>
    <p>Assumes the client <em>already has </em>an instance of some class which needs either a A or B version of a worker
        class.  </p>
    <p>Each alternative instance of  the existing class overrides a create method differently, each instantiating a
        different concrete product - typically one matching their own functionality. Benefit: no class reference
        language facilities required. </p>
    <p>Factory class is the only class that refers directly to concrete products. Client refers only to
        interface/abstract class.</p>
    <p>The choice is made via polymorphic override.</p>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_FactoryMethodGOF_01.gif" alt="" width="886"
            height="338" border="0" /></p>
    <p>Note that the choice as to which Work Manager (MgrA or MgrB) to instantiate in the first place is going to be an
        issue, but is not the point of this example.  The point is that once you have a particular brand of work
        manager, then you will get a related brand of of worker via the suitably overriden CreateWorker factory method.
    </p>
    <pre>WorkManager f = new MgrA()      // done somewhere in setup</pre>
    <!--mstheme-->
    <p> </p>
    <pre>Worker o = f.CreateWorker(key)</pre>
    <!--mstheme-->
    <p> </p>
    <pre>o.DoSomething()    // we don't know if its an A or a B.  Everything works ok.</pre>
    <!--mstheme-->
    <p>There will be parallel hierarchies, e.g. the WorkManager and the Worker hierarchies closely match, with A and B
        versions of their subclasses.  Start to think of a <em>family </em>of classes.</p>
    <p>My further thoughts, including a more detailed example of Factory Method <a
            href="http://www.atug.com/andypatterns/factory_method_example.htm">here</a>.</p>
    <h1>
        <!--mstheme--><span style="color: #663399;"><a name="AbsFactory"></a>Abstract Factory
            <!--mstheme--></span></h1>
    <p>Abstract factory similar to factory method, in that there is something being overridden.</p>
    <p>Abstract factory is the same as factory method, except there is  more than one Creation method.  E.g.
        CreateWorker, CreateAdministrator, CreatePoliceman - such that the class containing the factory methods might as
        well become a sole purpose class for dispensing these related classes.</p>
    <p>The abstract factory is a mere mechanism for delivering A versions of B versions.  E.g. Client wants A version of
        products</p>
    <p>Client programs against interfaces thus can switch between A or B.  Specifically, the client only talks to </p>
    <!--msthemelist-->
    <table style="width: 100%;" border="0" cellspacing="0" cellpadding="0">
        <!--msthemelist-->
        <tbody>
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">IAbstractProductFactory
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">IProduct1 
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">IProduct2 
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">IProduct3 
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
        </tbody>
    </table>
    <!--mstheme-->
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_AbsFactory_01.gif" alt="" width="1006"
            height="589" border="0" /></p>
    <pre>IAbstractProductFactory f = new ProductFactoryVersionA() <br />// choice is made at compile time, via factory method (run time) via strategy (runtime)<br />IProduct1 p1 = f.CreateProduct1()<br />IProduct2 p2 = f.CreateProduct2()<br />IProduct3 p3 = f.CreateProduct3()</pre>
    <!--mstheme-->
    <p>All products p1, p2, p3 are in the above example A versions, and compatible with each other.</p>
    <p>My further thoughts on Abstract Factory <a
            href="http://www.atug.com/andypatterns/abstract_factory_thoughts.htm">here</a>.</p>
    <p align="center"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvrule.gif" alt="" width="600"
            height="10" /></p>
    <h1>
        <!--mstheme--><span style="color: #663399;">Indirection - get to implementation A or B via intermediary
            <!--mstheme--></span></h1>
    <p>Rather than instantiate A or B and refer to them directly (albiet via a flexible interface variable), another
        approach is to refer to the same object all the time and hide the switching <em>behind </em>that object.</p>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_Indirection01.gif" alt="" width="858" height="266"
            border="0" /></p>
    <p>Now, because what is behind the intermediate object is hidden (and rightly so), you no longer need to program to
        the Strategy interface.</p>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_Indirection02.gif" alt="" width="854" height="277"
            border="0" /></p>
    <p>If you want to still program to an interface (good idea) then program to the Intermediary interface.  If you want
        to run free and wild, program to the intermediary object api.</p>
    <p>Variants are as follows:</p>
    <h2>
        <!--mstheme--><span style="color: #663399;">Proxy - methodless indirection using "demeter" referencing
            <!--mstheme--></span></h2>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_IndirectionStrategyPoorMans.gif" alt=""
            width="862" height="272" border="0" /></p>
    <p>Responsibility of the client to know the API of the strategy.  So still programming to the strategy interface. 
        You have to since the intermediary has no methods, or rather, has no methods specifically related to accessing
        the A &amp; B classes.</p>
    <pre>o = new Intermediary()<br />o.SetStrategy(new A())   // done in setup somewhere, or via a factory or via dependency injection framework</pre>
    <!--mstheme-->
    <p> </p>
    <pre>o.impl.DoSomething()</pre>
    <!--mstheme-->
    <h2>
        <!--mstheme--><span style="color: #663399;">Proper Strategy
            <!--mstheme--></span></h2>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_IndirectionStrategy01.gif" alt="" width="861"
            height="274" border="0" /></p>
    <pre>o = new Intermediary()<br />o.SetStrategy(new A())   // done in setup somewhere, or via a factory or via dependency injection framework</pre>
    <!--mstheme-->
    <p> </p>
    <pre>o.DoSomething()</pre>
    <!--mstheme-->
    <p>later you can switch the strategy without the client code caring.</p>
    <pre>o.SetStrategy(new B())<br />o.DoSomething()        // different behaviour or different implementation occurs</pre>
    <!--mstheme-->
    <h2>
        <!--mstheme--><span style="color: #663399;">Strategy with a touch of the Adapter pattern
            <!--mstheme--></span></h2>
    <p>If your implementation has a slightly different API than the one your client code wants to use, then you can
        adapt it at the same time as you are strategizing...</p>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_IndirectionStrategyAdapter.gif" alt="" width="864"
            height="274" border="0" /></p>
    <h2>
        <!--mstheme--><span style="color: #663399;">Proxy - going all the way
            <!--mstheme--></span></h2>
    <p>If your only have the same methods in your intermediary object as you have in your implementation, then you can
        have the intermediary inherit from the abstract implementation interface.  This turns the pattern into proxy,
        and lets you optionally, program to the Strategy interface again.</p>
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_IndirectionProxy.gif" alt="" width="865"
            height="320" border="0" /></p>
    <p>The proxy, whilst <em>inheriting </em>from Strategy, can also implement extra methods, though this is diverging a
        little from the intent of Proxy.<br /> An alternative to inheritance, the proxy can <em>implement the interface
        </em>of the Strategy class, and get some similar polymorphic substitutability benefits.</p>
    <p align="center"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvrule.gif" alt="" width="600"
            height="10" /></p>
    <h1>
        <!--mstheme--><span style="color: #663399;">Bridge
            <!--mstheme--></span></h1>
    <p>This is still a variant on accessing different behaviour via an intermediary.</p>
    <p>Bridge is just strategy with a oversized lhs context.</p>
    <p>Same as strategy except there is</p>
    <!--msthemelist-->
    <table style="width: 100%;" border="0" cellspacing="0" cellpadding="0">
        <!--msthemelist-->
        <tbody>
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Massive subclassing going on on the
                        lhs (the 'context' side).
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">The nature of the lhs methods are
                        more compositional, adaptive and far reaching (not just a simply strategy delegation)
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
        </tbody>
    </table>
    <!--mstheme-->
    <p><img src="http://www.atug.com/andypatterns/images/PathToBridge_Bridge01.gif" alt="" width="986" height="414"
            border="0" /></p>
    <h3>
        <!--mstheme--><span style="color: #663399;">Massive subclassing going on in the lhs. context
            <!--mstheme--></span></h3>
    <p>The reason is that you are wanting lots of methods and lots of functionality, lots of classes.  E.g. you want to
        have a GUI or DB subsystem, not just a single strategy.</p>
    <h3>
        <!--mstheme--><span style="color: #663399;">The nature of the lhs and rhs methods
            <!--mstheme--></span></h3>
    <p>Typically rhs (implementation/driver) calls are more primitive, and one lhs method will call the rhs. many times.
        e.g. see the DoTalk() method, above.</p>
    <p>The lhs methods can be diverse, comprising</p>
    <!--msthemelist-->
    <table style="width: 100%;" border="0" cellspacing="0" cellpadding="0">
        <!--msthemelist-->
        <tbody>
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">lhs method simply calls rhs method.
                        Method names can change or be the same. Simple delegation with no extra work.
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">lhs methods more complex and adapt
                        and do extra lines of code as needed
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Lots of logic in the lhs methods and
                        may have associated helper classes.  But in the end they call stuff on the intermediary api.
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
        </tbody>
    </table>
    <!--mstheme-->
    <h3>
        <!--mstheme--><span style="color: #663399;">Insulated from change.  Allow lhs and rhs to vary independently.
            <!--mstheme--></span></h3>
    <p>Client is insulated from changes. Should not talk talk to implementation, even if it is the abstract
        implementation interface because the abs impl. may change. If the abstract implementation interface does change
        then this affects only the Intermediary but not the client code.  Client code should thus only talk to
        intermediary.</p>
    <p>Similarly, if you change the Intermediary API, then only the client is affected - the r.h.s. (the abstract
        implementation interface and concrete implementations) are not affected.</p>
    <p>In this sense the lhs and rhs can vary independently.  Ok - so there are repercussions when things vary - but
        they are limited, as discussed above.</p>
    <h3>
        <!--mstheme--><span style="color: #663399;">Final thought on Bridge
            <!--mstheme--></span></h3>
    <p>You could simplify Bridge and have the client code talk directly to the rhs. abstract implementation interface.  
        You would be reverting to where we started on this "road to Bridge".   Nothing wrong with that - but you would
        lose the 'insulation against change' that Bridge gets you.  And with Bridge the lhs can have lots of complex
        logic and the rhs implementations need only implement the more primitive operations.  That is a big win.</p>
    <h2>
        <!--mstheme--><span style="color: #663399;">Solutions overview
            <!--mstheme--></span></h2>
    <p>Summary of the ways of coupling your components</p>
    <table style="width: 100%;" border="1">
        <tbody>
            <tr>
                <td align="center" width="18%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"><strong>Technique</strong>
                        <!--mstheme--></span></td>
                <td align="center" width="21%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"><strong>Meta-Pattern</strong>
                        <!--mstheme--></span></td>
                <td align="center" width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"><strong>Pattern</strong>
                        <!--mstheme--></span></td>
                <td align="center" width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"><strong>Description</strong>
                        <!--mstheme--></span></td>
                <td align="center" width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td rowspan="8" bgcolor="#ffff99" width="18%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">To implementation A or B directly
                        <!--mstheme--></span></td>
                <td rowspan="2" bgcolor="#cccccc" width="21%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Program to Interface
                        <!--mstheme--></span></td>
                <td rowspan="2" bgcolor="#ffff99" width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Interface
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Interface, compile time choice
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Alternative implementations of an
                        interface. Instantiate one or the other implementation of that interface. The code that uses the
                        object is unaware of which object it is using. "Program to an interface"
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Interface, conditional code
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Same solution as above, except
                        choose particular implementation dynamically at runtime using a flag.
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td rowspan="6" bgcolor="#ffffcc" width="21%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Factory
                        <!--mstheme--></span></td>
                <td rowspan="3" bgcolor="#ccffff" width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Factory Method
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">conditional code
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">registry
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">polymorphic factory method
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td rowspan="3" bgcolor="#ccccff" width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Abstract Factory
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">abstract factory - polymorphic
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">conditional code
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">class registry
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td rowspan="6" bgcolor="#ccffcc" width="18%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">To implementation A or B via
                        intermediary
                        <!--mstheme--></span></td>
                <td rowspan="6" bgcolor="#ffccff" width="21%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Indirection
                        <!--mstheme--></span></td>
                <td width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Dot notation drilling
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">methodless proxy using demeter
                        referencing
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Strategy
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">strategy - may be extra methods not
                        related to the strategising
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Proxy
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">proxy, all methods mapped (demeter
                        is happy). inherit
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Adapter
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">adapted proxy-like strategy. 
                        different method names sometimes
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
            <tr>
                <td bgcolor="#ffffcc" width="36%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"><span
                            style="background-color: #ffffcc;">Bridge</span>
                        <!--mstheme--></span></td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">rhs - methods usually more
                        primitive.  Only talk to abs. impl. </span>
                    <p><span style="font-family: Arial,Arial,Helvetica;">lhs - all adapted &amp; thus changeable. can
                            build hierarchies
                            <!--mstheme--></span></p>
                </td>
                <td width="25%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;"> 
                        <!--mstheme--></span></td>
            </tr>
        </tbody>
    </table>
    <!--mstheme-->
    <h2>
        <!--mstheme--><span style="color: #663399;">Final thoughts
            <!--mstheme--></span></h2>
    <p>The presentation of the patterns form a story of simple to complex.  </p>
    <p>And its a story of two broadly different techniques, </p>
    <!--msthemelist-->
    <table style="width: 100%;" border="0" cellspacing="0" cellpadding="0">
        <!--msthemelist-->
        <tbody>
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Getting to the implementation A or B
                        directly
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Getting to the implementation A or B
                        via an intermediary object
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
        </tbody>
    </table>
    <!--mstheme-->
    <h3>
        <!--mstheme--><span style="color: #663399;">Adapter vs. Bridge
            <!--mstheme--></span></h3>
    <p>Adapter is closer to Bridge in that the adaptation on the lhs. (the context) can be not just a renaming and
        mapping of methods, but extra logic and whatever it takes to make the adapation work.  So the lhs. is closer to
        the free wheeling compositional lhs of Bridge Pattern.  By compositional I mean that a single lhs. method can
        comprise of complex code and multiple calls to the rhs. methods.  In Bridge the lhs methods can even call on
        other methods in the same lhs, whereas in Adapter this is not really the intent.</p>
    <h3>
        <!--mstheme--><span style="color: #663399;">IOC (inverison of control) also fits in here somewhere.
            <!--mstheme--></span></h3>
    <p>Dependency injection.  Inject a context object or wire up dependent objects. Allows you to program normally. 
        Allows different implementations to be injected in.</p>
    <h3>
        <!--mstheme--><span style="color: #663399;">Microkernels also fit in here.
            <!--mstheme--></span></h3>
    <p>Amongst other things, a Microkernel style architecture allows alternative plugins (services) to fulfil the
        implementation.  </p>
    <!--msthemelist-->
    <table style="width: 100%;" border="0" cellspacing="0" cellpadding="0">
        <!--msthemelist-->
        <tbody>
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Maybe think of it as
                        <em>service</em> A or B.  
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
            <tr>
                <td valign="baseline" width="42"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvbul1.gif"
                        alt="bullet" width="15" height="15" hspace="13" /></td>
                <td valign="top" width="100%">
                    <!--mstheme--><span style="font-family: Arial,Arial,Helvetica;">Or <em>plugin </em>A or B.
                        <!--mstheme--></span>
                    <!--msthemelist-->
                </td>
            </tr>
            <!--msthemelist-->
        </tbody>
    </table>
    <!--mstheme-->
    <p>There seem to be three types of MicroKernel:</p>
    <ol>
        <li>Service location, like COM where you either ask for a service and get an interface which you use, or you
            call a service and the late binding binds to an appropriate service at the last minute. <strong>Style of
                programming:</strong> slightly different - must ask for an interface before using it.</li>
        <li>Message broadcasting kernel, where messages are broadcast to all plugins and the chain of responsibility
            pattern is used, and a plugin/service which can make sense of the message acts on it (either consuming it or
            passing it on for someone else to have a go at). <strong>Style of programming: </strong>different - you must
            create messages send them into the kernel, either synchronously or asynchronously.</li>
        <li>Dependency Injection Microkernel, where all object attributes refering to other objects (dependencies) are
            injected for you by a framework.  Rather than setting up these references yourself manually, as normal
            programming style dictates, you leave it to magic - which allows other implementations to be swapped in. You
            must of course program to interfaces not to concrete classes, in order for this trick to work. 
            <strong>Style of programming: </strong>normal, you just call methods on objects that you have references
            to.  The fact that the references have been wired up by a framework (which consults a plugin directory &amp;
            setup file telling us which plugins are active) is hidden from us.</li>
    </ol>
    <p>Maybe one or more of the above three descriptions of a Microkernel is not actually a microkernel - I am just
        learning about this stuff.  But I have seen references that suggest my analysis is correct. E.g. The <a
            href="http://www.castleproject.org/castle/show/Windsor+Container">Castle</a> IOC framework for .NET calls
        itself a microkernel.  </p>
    <h3>
        <!--mstheme--><span style="color: #663399;">A variable of type interface is really a another 'secret' form of
            indirection
            <!--mstheme--></span></h3>
    <p>I have made a broad distinction between accessing implementations A or B either directly or via an intermediary.
        Thinking about it some more, when you do access A or B directly, you do so via an an intermediary variable
        declared of type abstract/interface.  This is when you are being good and 'programming to interfaces'.</p>
    <p>Thus you could argue that even even when you are accessing an object (implementation A or B) directly, you are in
        fact still acting through an intermediary - the interface variable. !</p>
    <p align="center"><img src="http://www.atug.com/andypatterns/_themes/canvas/acnvrule.gif" alt="" width="600"
            height="10" /></p>
    <p>Comments?  Please <a href="mailto:abulka@netspace.net.au">email me</a>.</p>
</body>

</html>